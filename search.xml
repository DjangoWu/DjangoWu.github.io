<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MLCC笔记]]></title>
    <url>%2F2018%2F04%2F17%2FMLCC%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题构建 (Framing)：机器学习主要术语标签是我们要预测的事物，即简单线性回归中的 y 变量。标签可以是小麦未来的价格、图片中显示的动物品种、音频剪辑的含义或任何事物。 特征是输入变量，即简单线性回归中的 x 变量。简单的机器学习项目可能会使用单个特征，而比较复杂的机器学习项目可能会使用数百万个特征， 样本是指数据的特定实例：x。（我们采用粗体 x 表示它是一个矢量。）我们将样本分为以下两类： 有标签样本 无标签样本 模型定义了特征与标签之间的关系。例如，垃圾邮件检测模型可能会将某些特征与“垃圾邮件”紧密联系起来。 模型生命周期的两个阶段： 训练表示创建或学习模型。也就是说，您向模型展示有标签样本，让模型逐渐学习特征与标签之间的关系。 推断表示将训练后的模型应用于无标签样本。 回归模型可预测连续值。例如，回归模型做出的预测可回答如下问题： 加利福尼亚州一栋房产的价值是多少？ 用户点击此广告的概率是多少？ 分类模型可预测离散值。例如，分类模型做出的预测可回答如下问题： 某个指定电子邮件是垃圾邮件还是非垃圾邮件？ 这是一张狗、猫还是仓鼠图片？ 训练模型表示通过有标签样本来学习（确定）所有权重和偏差的理想值。在监督式学习中，机器学习算法通过以下方式构建模型：检查多个样本并尝试找出可最大限度地减少损失的模型；这一过程称为经验风险最小化。 损失是对糟糕预测的惩罚。也就是说，损失是一个数值，表示对于单个样本而言模型预测的准确程度。如果模型的预测完全准确，则损失为零，否则损失会较大。训练模型的目标是从所有样本中找到一组平均损失“较小”的权重和偏差。 降低损失 梯度下降法一种通过计算并且减小梯度将损失降至最低的技术，它以训练数据为条件，来计算损失相对于模型参数的梯度。通俗来说，梯度下降法以迭代方式调整参数，逐渐找到权重和偏差的最佳组合，从而将损失降至最低。 梯度下降法算法用梯度乘以一个称为学习速率（有时也称为步长）的标量，以确定下一个点的位置。 随机梯度下降法（SGD）在梯度下降法中，批量(batch)指的是用于在单次迭代中计算梯度的样本总数。 随机梯度下降法 (SGD) ，它每次迭代只使用一个样本（批量大小为 1）。如果进行足够的迭代，SGD 也可以发挥作用，但过程会非常杂乱。“随机”这一术语表示构成各个批量的一个样本都是随机选择的。 小批量随机梯度下降法（小批量 SGD）是介于全批量迭代与 SGD 之间的折衷方案。小批量通常包含 10-1000 个随机选择的样本。小批量 SGD 可以减少 SGD 中的杂乱样本数量，但仍然比全批量更高效。 泛化(Generalization) 训练集 - 用于训练模型的子集。 测试集 - 用于测试模型的子集。 机器学习细则以下三项基本假设阐明了泛化： 我们从分布中随机抽取独立同分布 (i.i.d) 的样本。换言之，样本之间不会互相影响。（另一种解释：i.i.d. 是表示变量随机性的一种方式）。 分布是平稳的；即分布在数据集内不会发生变化。 我们从同一分布的数据划分中抽取样本。 表示法独热编码(One-Hot Encoding)又可称为一位有效编码，其方法是使用N位状态寄存器来对N个状态进行编码，每个状态都由他独立独立的寄存器位，并且在任意时候，其中只有一位有效。 例如 自然状态码为：000,001,010,011,100,101独热编码为：000001,000010,000100,001000,010000,100000 可以这样理解，对于每一个特征，如果它有m个可能值，那么经过独热编码后，就变成了m个二元特征（如成绩这个特征有好，中，差变成one-hot就是100, 010, 001）。并且，这些特征互斥，每次只有一个激活。因此，数据会变成稀疏的。 这样做的好处主要有： 解决了分类器不好处理属性数据的问题 在一定程度上也起到了扩充特征的作用 参考 表示(Representation): 良好特征的特点 避免很少使用的离散特征值 最好具有清晰明确的含义 不要将“神奇”的值与实际数据混为一谈 解决神奇值，需要将该特征转换为两个特征: 一个特征只存储质量评分，不含神奇值 一个特征存储布尔值，表示是否提供了quality_rating。为该布尔值特征指定一个名称，例如：is_quality_rating_defined。 考虑上游不稳定性 表示(Representation): 清理数据缩放特征值缩放是指将浮点特征值从自然范围（例如 100 到 900）转换为标准范围（例如 0 到 1 或 -1 到 +1）。如果某个特征集只包含一个特征，则缩放可以提供的实际好处微乎其微或根本没有。不过，如果特征集包含多个特征，则缩放特征可以带来以下优势： 帮助梯度下降法更快速地收敛。 帮助避免“NaN 陷阱”。在这种陷阱中，模型中的一个数值变成 NaN（例如，当某个值在训练期间超出浮点精确率限制时），并且模型中的所有其他数值最终也会因数学运算而变成 NaN。 帮助模型为每个特征确定合适的权重。如果没有进行特征缩放，则模型会对范围较大的特征投入过多精力。 处理离群特征值 对数缩放 最大值限制 分箱例如对经纬度样本使用整数进行分箱操作，另一种方法是按分位数分箱，这种方法确保每个桶内的样本数量是相等的。按分位数分箱无须担心离群值。 清查在现实生活中，数据集中的很多样本是不可靠的，原因有以下一种或多种： 遗漏值。 例如，有人忘记为某个房屋的年龄输入值。 重复样本。 例如，服务器错误地将同一条记录上传了两次。 不良标签。 例如，有人错误地将一颗橡树的图片标记为枫树。 不良特征值。 例如，有人输入了多余的位数，或者温度计被遗落在太阳底下。 一旦检测到存在这些问题，您通常需要将相应样本从数据集中移除，从而“修正”不良样本。要检测遗漏值或重复样本，您可以编写一个简单的程序。检测不良特征值或标签可能会比较棘手。 除了检测各个不良样本之外，您还必须检测集合中的不良数据。直方图是一种用于可视化集合中数据的很好机制。此外，收集如下统计信息也会有所帮助： 最大值和最小值 均值和中间值 标准偏差 了解数据遵循以下规则： 记住您预期的数据状态。 确认数据是否满足这些预期（或者您可以解释为何数据不满足预期）。 仔细检查训练数据是否与其他来源（例如信息中心）的数据一致。 像处理任何任务关键型代码一样谨慎处理您的数据。良好的机器学习依赖于良好的数据。 特征组合(Feature Crosses)特征组合是指通过将两个或多个输入特征相乘来对特征空间中的非线性规律进行编码的合成特征。 为什么要特征组合 线性学习器可以很好地扩展到大量数据，例如vowpal-wabit、sofia-ml 不过，如果不使用特征组合，这些模型的表现度将受到限制 使用特征组合 + 大量数据是学习高度复杂模型的一种有效策略 神经网络可提供另一种策略 正则化：简单性目的是为了防止过拟合 降低模型的复杂度： 我们希望尽可能降低模型的复杂度 我们可以将这种想法纳入训练时所进行的优化中 经验风险最小化： 只在减少训练误差： minimize: Loss(Data|Model) 同时平衡复杂度： minimize: Loss(Data|Model)+complexity(Model) (一个是损失项，用于衡量模型与数据的拟合度，另一个是正则项，用于衡量模型复杂度) 课程介绍了两种衡量模型复杂度的常见方式： 将模型复杂度作为模型中所有特征的权重的函数 将模型复杂度作为具有非零权重的特征总数的函数 正则化： 如何定义复杂度(模型)？ 首选较小的权重 偏离将会产生成本 可以通过L2正则化(也称为岭正则化)对这种想法编码 复杂度(模型) = 权重的平方和 减少非常大的权重 对于线性模型：首选比较平缓的斜率 对贝叶斯先验概率： 权重应该以0为中心 权重应该呈正太分布 L2正则化损失函数： 模型开发者通过以下方式来调整正则化项的整体影响：用正则化项的值乘以lambda(又称为正则化率)的标量。也就是执行下面运算： minimize(Loss(Data|Model) + &#x03BB; &#xA0;complexity(Model)) 执行 L2 正则化对模型具有以下影响： 使权重值接近于 0（但并非正好为 0） 使权重的平均值接近于 0，且呈正态（钟形曲线或高斯曲线）分布。 增加lambda值将增强正则化效果，降低lambda的值往往会得到较为平缓的直方图(权重频率/权重值) 在选择 lambda 值时，目标是在简单化和训练数据拟合之间达到适当的平衡： 如果您的 lambda 值过高，则模型会非常简单，但是您将面临数据欠拟合的风险。您的模型将无法从训练数据中获得足够的信息来做出有用的预测。 如果您的 lambda 值过低，则模型会比较复杂，并且您将面临数据过拟合的风险。您的模型将因获得过多训练数据特点方面的信息而无法泛化到新数据。 注意：将 lambda 设为 0 可彻底取消正则化。 在这种情况下，训练的唯一目的将是最小化损失，而这样做会使过拟合的风险达到最高。 逻辑回归(Logistic Regression)逻辑回归： 许多问题需要将概率估算值作为输出 输入逻辑回归 很方便，因为概率估算值已经过校准 例如，p(待出售房屋) * 价格 = 预期价格 此外，它在我们需要二元分类时非常有用 垃圾邮件或非垃圾邮件？-&gt; p(垃圾邮件) 逻辑回归和正则化： 正则化对于逻辑回归而言至关重要 记住渐近线 它会不断尝试促使损失在高纬度空间内达到0 以下两个策略尤为重要 L2正则化(也称为L2权重衰减) - 用于降低超大权重 早停法 - 用于限制训练步数或学习速率 线性逻辑回归 线性逻辑回归极其高效 超快的训练速度和较短的预测时间 短模型/宽度模型占用大量RAM 总结： 逻辑回归模型会生成概率 对数损失函数是逻辑回归的损失函数 逻辑回归被很多从业者广泛使用 分类如何评估分类模型：评估标准：准确率(正确预测所占比例) 准确率可能存在误导性： 最常是在不同类型的错误具有不同代价时 典型情况包括分类不平衡，即正类别或负类别极其罕见时 真正例和假正例TP = 真正例，TN = 真负例， FP = 假正例， FN = 假负例 评估指标：精确率和召回率 精确率：(真正例次数)/(所有正类别预测次数) = TP / (TP + FP) 当模型的预测为“正”类别时，预测正确吗？ 直觉：模型是否过于频繁地提醒说“狼来了”？ 召回率：(真正例次数)/(所有实际类别数) = TP / (TP + FN) 在所有可能的正类别中，模型正确地识别出了多少？ 直觉：是否漏掉了任何“狼来了”的情况？ 要全面评估模型的有效性，必须同时检查精确率和召回率，但是，精确率和召回率往往是此消彼长的情况。 ROC曲线ROC曲线(接收者操作特征曲线)是一种显示分类模型在所有分类阈值下的效果的图标。 真正例率(TPR) = TP / (TP + FN) 假正例率(FPR) = FP / (FP + TN) 评估指标:曲线下面积(Area Under Curve)(看做模型将某个随机正类别样本排列在某个随机负类别样本之上的概率) 实用原因： 曲线下面积的尺度不变，它测量预测的排名情况，而不是测量其绝对值 曲线下面积的分类阈值不变，它测量模型预测的质量，而不考虑所选的分类阈值 局限性： 并非总是希望尺度不变，例如：有时需要被良好校准的概率输出，而曲线下面积无法告诉我们这一结果。 并非总是希望分类阈值不变， 在假负例与假正例的代价存在较大差异的情况下，尽量减少一种类型的分类错误可能至关重要。例如，在进行垃圾邮件检测时，您可能希望优先考虑尽量减少假正例（即使这会导致假负例大幅增加）。对于此类优化，曲线下面积并非一个实用的指标。 预测偏差逻辑回归预测应当无偏差。 预测平均值 == 观察平均值偏差是一个具有指示作用的值 仅仅是零偏差并不能说明系统中的一切都完美无缺 但偏差是一项非常实用的健全性检查项目 如果出现偏差，则说明存在问题： 特征集不完整？ 数据集混乱？ 模型实现流水线中有错误？ 训练样本有偏差？ 正则化过强？ 请勿实用校准层来修正偏差，而应在模型中予以修正 校准修复的是症状，而不是原因 建立了一个更脆弱的系统，并且必须持续更新 查看各部分数据是否存在偏差-这有助于指导如何进行改进。 正则化：稀疏性注意：稀疏特征组合可能会大大增加特征空间可能出现问题： 模型大小(RAM)可能会变得庞大 “噪点”系数(导致过拟合) L1和L2采用不同的方式降低权重： L2会降低权重2 L1会降低|权重|因此，L2和L1具有不同的导数： L2的导数为2 * 权重 L1的导数为k(一个常数，其值与权值无关) 您可以将 L2 的导数的作用理解为每次移除权重的 x%。如 Zeno 所知，对于任意数字，即使按每次减去 x% 的幅度执行数十亿次减法计算，最后得出的值也绝不会正好为 0。（Zeno 不太熟悉浮点精度限制，它可能会使结果正好为 0。）总而言之，L2 通常不会使权重变为 0。您可以将 L1 的导数的作用理解为每次从权重中减去一个常数。不过，由于减去的是绝对值，L1 在 0 处具有不连续性，这会导致与 0 相交的减法结果变为 0。例如，如果减法使权重从 +0.1 变为 -0.2，L1 便会将权重设为 0。就这样，L1 使权重变为 0 了。 注意：L1正则化可能会使以下类型的特征权重正好为0： 信息缺乏的特征 不同程度的信息丰富的特征 与其他类似的信息丰富特征密切相关的信息丰富特征 L1正则化会对L0权重的范数进行惩罚 非凸优化；NP困难比较放松的L1正则化： 对绝对值(权重)之和进行惩罚 凸优化问题 和L2不同，L1鼓励稀疏性 神经网络(Neural Networks)神经网络标准组件： 一组节点，类似于神经元，位于层中 一组权重，表示每个神经网络层与其下方的层之间的关系。下方的层可能是另一个神经网络层，也可能是其他类型的层 一组偏差，每个节点一个偏差 一个激活函数，对曾中每个节点的输出进行转换。不同的层可能拥有不同的激活函数注意：神经网络不一定始终比特征组合好，但它的确可以提供适用于很多情形的灵活替代方案 反向传播算法注意： 梯度很重要 如果它是可微的，则我们也许能够对其进行学习 梯度可能消失 每个额外的层都会依次降低信噪比 Relu在这里很有用 梯度可能会爆炸 学习速率在这里很重要 批标准化(实用按钮)可以提供帮助 Relu层可能会消失 保持冷静，并降低您的学习速率 标准化特征值 我们希望特征具有合理的范围 大致以0位中心，[-1, 1]的范围通常效果比较好 有助于梯度下降法收敛；避免NaN陷阱 避免离群值也会有帮助 可以使用一些标准方法 线性缩放 为最大值和最小值设定硬性上下限(截断) 对数缩放 丢弃正则化 丢弃：另一种正则化形式，对神经网络很有用 工作原理是，在一个梯度步长中随机“丢弃”网络的单元 有一个可用于集成学习此处的模型的连接 丢弃的越多，正则化效果就越强 0.0 = 无丢弃正则化 1.0 = 丢弃所有内容！学不到任何规律 中间值更有用 多类别神经网络SoftMax方程式 SoftMax多类别 添加了附加限制：要求所有一对多节点的输出总和为1.0 附加限制有助于快速训练收敛 另外，允许输出解析为概率 SoftMax选项 完整SoftMax 暴力破解；针对所有类别进行计算 候选采样 针对所有正类别标签进行计算，但仅针对负类别标签的随机样本进行计算 何时使用何种类别？ 多类别单一标签分类： 一个样本可能只是一个类别的成员 类别互斥这一限制是有用的结构 有助于在损失中对此进行编码 将一个softmax损失用于所有可能的类别 多分类多标签分类： 一个样本可能是多个类别的成员 无需对类别成员资格设定额外的限制 将一个逻辑回归损失用于每个可能的类别 嵌套(Embedding)嵌套是一种相对低维的空间，您可以将高维矢量映射到这种低维空间里。通过使用嵌套，可以让在大型输入（比如代表字词的稀疏矢量）上进行机器学习变得更加容易。在理想情况下，嵌套可以将语义上相似的不同输入映射到嵌套空间里的邻近处，以此来捕获输入的语义。一个模型学习到的嵌套，也可以被其他模型重用。 协同过滤的目的协同过滤是一项可以预测用户兴趣(根据很多其他用户的兴趣)的任务。 分类输入数据分类数据是指用于表示一组有限选项中的一个或多个离散项的输入特征。例如，它可以是某用户观看过的一组影片，某文档中使用的一系列单词，或某人从事的职业。分类数据的最高效表示方式是使用稀疏张量(一种含有极少非零元素的张量)。 转换到低维度空间解决稀疏输入数据的核心问题，可以将高维度数据映射到低维度空间。 获取嵌套 标准降维技术：如PCA Word2vec：基于分布假设，将语义上相似的字词映射到几何图形上邻近的嵌套矢量。 将嵌套训练位大型模型的一部分： 在深度网络中学习嵌套 无需单独的训练过程，也就是说，嵌套层只是隐藏层，每个维度一个单元 监督式信息（例如用户观看了两部相同的影片）针对所需任务调整学到的嵌套 隐藏单元直观地发现如何整理 d 维空间中的各项，才能最大限度地优化最终目标 选择嵌套维度个数 嵌套维度的个数越多，越能准确地表示输入值之间的关系 不过，维度个数越多，过拟合的可能性就越高，训练速度也会越慢 经验法则（一个不错的起点，但应使用验证数据进行微调）： 嵌套充当工具 嵌套会以相似内容彼此靠近的方式将各项内容（如影片、文字等）映射到低维实矢量 嵌套也可应用于密集数据（如音频），以创建有意义的相似度指标 联合嵌套多种类型的数据（如文字、图片、音频等），以定义这些数据之间的相似度 机器学习工程生产环境及其学习系统(Production ML Systems) 系统级组件：无须自行构建所有内容 尽可能重复使用常规机器学习系统组件。 Google CloudML 解决方案包括 Dataflow 和 TF Serving 您还可以在 Spark、Hadoop 等其他平台中找到组件 如何知道自己需要哪些组件？ 了解机器学习系统的一些范例及其要求 静态训练与动态训练(Static vs. Dynamic Training) 静态模型采用离线训练方式。也就是说，我们只训练模型一次，然后使用训练后的模型一段时间。 易于构建和测试 - 使用批量训练和测试，对其进行迭代，直到达到良好效果。 仍然需要对输入进行监控 模型容易过时 动态模型采用在线训练方式。也就是说，数据会不断进入系统，我们通过不断地更新系统将这些数据整合到模型中。 随着时间推移不断为训练数据注入新数据，定期同步更新版本。 使用渐进式验证，而不是批量训练和测试 需要监控、模型回滚和数据隔离功能 会根据变化作出相应调整，避免了过时问题 静态推理与动态推理 (Static vs. Dynamic Inference) 离线推理，指的是使用 MapReduce 或类似方法批量进行所有可能的预测。然后，将预测记录到 SSTable 或 Bigtable 中，并将它们提供给一个缓存/查询表。 优点：不需要过多担心推理成本。 优点：可以使用批量方法。 优点：可以在推送之前对数据预测执行后期验证。 缺点：只能对我们知晓的数据进行预测，不适用于存在长尾的情况。 缺点：更新可能延迟数小时或数天。 在线推理，指的是使用服务器根据需要进行预测。 优点：可在新项目加入时对其进行预测，非常适合存在长尾的情况。 缺点：计算量非常大，对延迟较为敏感，可能会限制模型的复杂度。 缺点：监控需求更多。 数据依赖关系特征管理 输入数据（特征）决定机器学习系统的行为。 我们可以针对软件库编写单元测试，但数据呢？ 选择输入信号时要谨慎。 甚至比决定要依赖哪个软件库时更谨慎吗？ 对输入数据提出的问题： 可靠性 信号不可用时会出现什么情况？您知道吗？例如： 信号是否来自因负载过重而崩溃的服务器？ 信号是否来自每年 8 月去度假的人群？ 版本控制 计算此信号的系统是否发生过变化？多久一次？会出现什么情况？如果是： 多久一次？ 您如何知道系统发生变化的时间？ 必要性 信号的实用性是否能证明值得添加此信号？ 相关性 是否有任何输入信号密不可分，以至于需要采取额外策略来梳理它们？ 反馈环 哪个输入信号可能会受到我的模型输出的影响？ 有效的机器学习准则 确保第一个模型简单易用。 着重确保数据管道的正确性。 使用简单且可观察的指标进行训练和评估。 拥有并监控您的输入特征。 将您的模型配置视为代码：进行审核并记录在案。 记下所有实验的结果，尤其是“失败”的结果。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头号玩家-彩蛋普拉斯]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%A4%B4%E5%8F%B7%E7%8E%A9%E5%AE%B6-%E5%BD%A9%E8%9B%8B%E6%99%AE%E6%8B%89%E6%96%AF%2F</url>
    <content type="text"><![CDATA[看完这部电影，我能想到的两个词就是感动和伟大。 头号玩家，我觉得叫彩蛋普拉斯也完全没问题，这里头埋了太多太多的彩蛋，简直就是一场游戏迷和电影迷的狂欢了。第一次在影院观影让我不止一次的想大声惊呼，霸王龙和金刚出现在赛道上、钢铁巨人的出场、高达变身大战哥斯拉、最后主角释放的气功波、甚至就连公民凯恩里的玫瑰花蕾都出现了，每每如此总是慨叹自己的词穷，只能用这样笨拙的表达方式。 斯皮尔伯格，他已经给我们留下了太多太多的经典作品了，ET、大白鲨等等。真没想到这个现在已经七十三岁的老爷子居然还有如此想象力与创造力，整部电影穿插了各种科幻元素、音乐元素和游戏、动漫、电影梗，数不胜数，让人眼花缭乱目不暇接。这一次，我是真的彻底服气了，真想对着他竖一个终结者2的大拇指说声牛逼。尽管整部电影本身故事性比较弱，并且存在着一些不大不小的BUG，但我一直觉得能让人感受到快乐的电影就是好电影。而在这部电影里，我收获的不止是快乐，还有感动。 借用豆瓣网友的一句话 斯皮尔伯格把他对电影的梦想、热心、爱与情怀，浓缩到这部片子，通过极具年代感的经典电影和角色，又并茂高科技的现代游戏闯关，他拿手的、专注的、想诉说的都在这里给影迷情倾盆呈现，并在最后一句“谢谢你玩我的游戏”推向高潮，就像在银幕前看着他对我们说“谢谢你看我的电影”。 谢谢你玩我的游戏，这句话里致敬了太多太多的东西了。最近在玩荒野之息，真真切切的能感受到制作者倾注的心血，四年磨一剑才能让玩家在每一秒的探索中都能感受到惊喜。这不仅仅是个例，这句话也不仅仅只是一句带着情怀的话。 老爷子，也谢谢你拍了这样的电影给我们看。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>头号玩家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战-Logistic回归]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98-Logistic%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); 机器学习–Logistic回归计算过程的推导这篇博客讲的超赞，很详细，书里面略去了很多细节，比如一些中间项的推导 利用Logistic 回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，依此进行分类回归一词源自拟合，表示要找到最佳拟合参数集。 一般流程 收集数据： 可采用任何方法 准备数据： 由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。 分析数据： 采用任意方法对数据进行分析 训练算法： 大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。 测试数据： 一旦训练步骤完成，分类将会很快 使用算法： 首先，我们需要输入一些数据，并将其转换成对应的结构化数值，判定它们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。 采用Logistic回归和Sigmoid函数的分类优点： 计算代价不高，易于理解和实现缺点： 容易欠拟合，分类精度可能不高使用数据范围： 数值型和标称型数据。 Sigmoid函数的输入记为z，则$$z=w_0x_0+w_1x_1+w_2x_2+…+w_nx_n = w^Tx$$ 梯度上升法(具体推导过程见文章开头链接)$$w := w + \alpha\nabla_wf(w)$$ 梯度下降算法梯度下降算法与这里的梯度上升算法是一样的，只是公式中的加法需要变成减法：$$w := w - \alpha\nabla_wf(w)$$梯度上升算法用来求函数的最大值，而梯度下降算法用来求函数的最小值 python代码实现 梯度上升算法 12345678910111213141516def sigmoid(inX): return 1.0 / (1 + exp(-inX))def gradAscent(dataMatIn, classLabels): "Logistic 回归梯度上升优化" dataMatrix = mat(dataMatIn) labelMat = mat(classLabels).transpose() m, n = shape(dataMatrix) alpha = 0.001 maxCycles = 500 weights = ones((n, 1)) for k in range(maxCycles): h = sigmoid(dataMatrix * weights) error = (labelMat - h) weights = weights + alpha * dataMatrix.transpose() * error return weights 随机梯度上升一次仅用一个样本点来更新回归系数。 12345678910111213141516# 伪代码所有回归系数初始化为1对数据集中每个样本 计算该样本的梯度 使用alpha * gradient更新回归系数值返回回归系数值def stocGradAscent0(dataMatrix, classLabels): m,n = shape(dataMatrix) alpha = 0.01 weights = ones(n) #initialize to all ones for i in range(m): h = sigmoid(sum(dataMatrix[i]*weights)) error = classLabels[i] - h weights = weights + alpha * error * dataMatrix[i] return weights 改进的随机梯度上升算法 12345678910111213def stocGradAscent1(dataMatrix, classLabels, numIter=150): m, n = shape(dataMatrix) weights = ones(n) for j in range(numIter): dataIndex = list(range(m)) for i in range(m): alpha = 4/(1.0+j+i)+0.01 # alpha每次迭代时需要调整 randIndex = int(random.uniform(0, len(dataIndex))) # 随机选取更新 h = sigmoid(sum(dataMatrix[randIndex]*weights)) error = classLabels[randIndex] - h weights = weights + alpha * error * dataMatrix[randIndex] del(dataIndex[randIndex]) return weights 两处改动: alpha在每次迭代的时候都会调整，这可以缓解数据波动或者高频波动。虽然aplha会随着迭代次数不断减小，但永远不会减小到0，因为其中存在常数项。这样做的原因是为了保证在多次迭代之后新数据仍然具有一定的影响。如果要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。还有一点就是这样选择的alpha不是严格下降的。(避免参数的严格下降也常见于模拟退火算法等其他优化算法中) 通过随机选取样本来更新回归系数，这种方法将减少周期性的波动。 处理数据中的缺失值 使用可用特征的均值来填补缺失值 使用特殊值来填补缺失值，如-1 忽略有缺失值的样本 使用相似样本的均值添补缺失值 使用另外的机器学习算法预测缺失值]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习实战读书笔记]]></title>
    <url>%2F2018%2F03%2F27%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); k-近邻算法概述k-近邻采用测量不同的特征值之间的距离方法进行分类。优点： 精度高、对异常值不敏感、无数据输入假定。缺点： 计算复杂度高、空间复杂度高。使用数据范围： 数值型和标称型。 一般流程 收集数据： 可采用任何方法 准备数据： 距离计算所需要的数值，最好是结构化的数据格式 分析数据： 可以使用任何方法 训练算法： 此步骤不适用于k-近邻算法 测试数据： 计算错误率 使用算法： 首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续的处理。 kNN分类伪代码对未知类别数据集中的每个点一次执行以下操作： 计算一直类数据集中的点与当前点之间的距离； 按照距离递增次序排序； 选取与当前点距离最小的k个点； 确定前k个点所在类别的出现频率； 返回前k个点出现频率最高的类别作为当前点的预测分类。 1234567891011121314151617def classify0(inX, dataSet, labels, k): "分类器" "@paramIn inX 测试数据" "@paramIn dataSet 训练数据集" "@paramIn labels 训练集标签" "@paramIn k k近邻" diffMat = tile(inX, (dataSet.shape[0], 1)) - dataSet sqDiffMat = diffMat ** 2 sqDistances = sqDiffMat.sum(axis=1) distances = sqDistances ** 0.5 sortedDistIndices = distances.argsort() classCount = &#123;&#125; for i in range(k): voteIlabel = labels[sortedDistIndices[i]] classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1 sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True) return sortedClassCount[0][0] 总结k-近邻算法是基于实例的学习，使用算法时： 必须有接近实际数据的训练样本数据。 必须保存全部数据集，如果训练数据集很大，必须使用大量的存储空间。 必须对数据集中的每个数据计算距离值，实际使用时可能非常耗时 另外，k-近邻算法无法给出任何数据的基础结构信息，因此也无法知晓平均实例样本和典型实例样本具有什么特征。 决策树概述优点： 计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。缺点： 可能会产生过度匹配问题。使用数据范围： 数值型和标称型。 一般流程 收集数据： 可采用任何方法 准备数据： 树构造算法只适用于标称型数据，因此数值型数据必须离散化 分析数据： 可以使用任何方法，构造树完成之后，我们应该检查图形是否符合预期 训练算法： 构造树的数据结构 测试数据： 使用经验树计算错误率 使用算法： 此步骤可使用于任何监督学习算法，而使用决策树可以更好地理解数据的内在含义 创建分支伪代码函数createBranch()12345678If so return 类标签Else 寻找划分数据集的最好特征 划分数据集 创建分支节点 for 每个划分的子集 调用函数createBranch并增加返回结果到分支节点中 return 分支节点 信息增益，香侬熵划分数据集的大原则是：将无序的数据变得更加有序。 组织杂乱无章数据的一种方法就是使用信息论度量信息，信息论是量化处理信息的分支科学。在划分数据集之前之后信息发生的变化称为信息增益，知道如何计算信息增益，就可以计算每个特征值划分数据集获得的信息增益，获得信息增益最高的特征就是最好的选择。 熵定义为信息的期望值。如果待分类的事物可能划分在多个分类之中，则符号$x_i$的信息定义为： $$l(x_i) = - \log_2p(x_i)$$ 为了计算熵，需要计算所有类别所有可能值包含的信息期望值： $$H = -\sum_{i=1}^{n}p(x_i)\log_{2}p(x_i)$$ 1234567891011121314def calcShannonEnt(dataSet): "计算给定数据的香侬熵" numEntries = len(dataSet) labelCounts = &#123;&#125; for featVec in dataSet: currentLabel = featVec[-1] if currentLabel not in labelCounts.keys() : labelCounts[currentLabel] = 0 labelCounts[currentLabel] += 1 shannonEnt = 0.0 for key in labelCounts: prob = float(labelCounts[key]) / numEntries shannonEnt -= prob * log(prob, 2) return shannonEnt 总结 决策树分类器就像带有终止块的流程图，终止块表示分类结果。开始处理数据集时，我们首先需要测量集合中数据的不一致性，也就是熵，然后寻找最优方案划分数据集，直到数据集中的所有数据属于同一分类。ID3算法可以用于划分标称型数据集。构建决策树时，通常采用递归的方法将数据集转化为决策树。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java和C++的二进制文件问题]]></title>
    <url>%2F2018%2F03%2F24%2FJava%E5%92%8CC-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[项目需要用到用Java读取C++生成的二进制文件，直接读取时存在错误。 因为需要考虑机器的大小端问题，Java程序采用的是大端字节序(左高右低), 而C++采用的是小端字节序(左低右高)。因此在读取数据时候需要转换下。 C++代码:123456789101112// 在c++中,用二进制方式写入数值 int main(int argc, char* argv[])&#123; ofstream outfile("c:\\d1.dat"); float f = 12.5f; outfile.write((char *)&amp;f,sizeof(float)); f = 3332.5f; outfile.write((char *)&amp;f,sizeof(float)); f = 1442.5224f; outfile.write((char *)&amp;f,sizeof(float)); outfile.close(); return 0; &#125; Java代码:1234567public static void main(String[] args) throws Exception &#123; File f = new File("c:/d1.dat"); CppInputStream dis = new CppInputStream(new FileInputStream(f)); System.out.println(dis.readFloat()); System.out.println(dis.readFloat()); System.out.println(dis.readFloat()); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 参见java.io.DataInputStream // C++写入的字节顺序是从低到高（左低到右高）， // 而java.io.DataInputStream读取的数据是从高到低（左高到右低) // 所以需要自己改写一下 public class CppInputStream extends FilterInputStream &#123; public CppInputStream(InputStream in) &#123; super(in); &#125; public final int read(byte b[]) throws IOException &#123; return in.read(b, 0, b.length); &#125; public final int read(byte b[], int off, int len) throws IOException &#123; return in.read(b, off, len); &#125; public final void readFully(byte b[]) throws IOException &#123; readFully(b, 0, b.length); &#125; public final void readFully(byte b[], int off, int len) throws IOException &#123; if (len &lt; 0) throw new IndexOutOfBoundsException(); int n = 0; while (n &lt; len) &#123; int count = in.read(b, off + n, len - n); if (count &lt; 0) throw new EOFException(); n += count; &#125; &#125; public final int skipBytes(int n) throws IOException &#123; int total = 0; int cur = 0; while ((total &lt; n) &amp;&amp; ((cur = (int) in.skip(n - total)) &gt; 0)) &#123; total += cur; &#125; return total; &#125; public final byte readByte() throws IOException &#123; int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return (byte) (ch); &#125; public final int readUnsignedByte() throws IOException &#123; int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return ch; &#125; public final short readShort() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (short) ((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); &#125; public final int readUnsignedShort() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0); &#125; public final char readChar() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (char) ((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); &#125; public final int readInt() throws IOException &#123; int ch4 = in.read(); int ch3 = in.read(); int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2 | ch3 | ch4) &lt; 0) throw new EOFException(); return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0)); &#125; private byte readBuffer[] = new byte[8]; public final long readLong() throws IOException &#123; readFully(readBuffer, 0, 8); return (((long) readBuffer[7] &lt;&lt; 56) + ((long) (readBuffer[6] &amp; 255) &lt;&lt; 48) + ((long) (readBuffer[5] &amp; 255) &lt;&lt; 40) + ((long) (readBuffer[4] &amp; 255) &lt;&lt; 32) + ((long) (readBuffer[3] &amp; 255) &lt;&lt; 24) + ((readBuffer[2] &amp; 255) &lt;&lt; 16) + ((readBuffer[1] &amp; 255) &lt;&lt; 8) + ((readBuffer[0] &amp; 255) &lt;&lt; 0)); &#125; public final float readFloat() throws IOException &#123; return Float.intBitsToFloat(readInt()); &#125; public final double readDouble() throws IOException &#123; return Double.longBitsToDouble(readLong()); &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode解题报告]]></title>
    <url>%2F2018%2F03%2F17%2FLeetCode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Stay hungry, stay foolishUntil 2018-03-24 19:36:43, I have solved 136 / 718 problems while 133 are still locked. Completion statistic: C++: 135 Python: 1 Solution: 68 Note: :lock: means you need to buy from LeetCode LeetCode Solution Table ID Title Difficulty C++ Python Solution 001 Two Sum Easy C++ To Do solution 002 Add Two Numbers Medium C++ To Do To Do 003 Longest Substring Without Repeating Characters Medium C++ To Do To Do 004 Median of Two Sorted Arrays Hard To Do To Do To Do 005 Longest Palindromic Substring Medium C++ To Do solution 006 ZigZag Conversion Medium To Do To Do To Do 007 Reverse Integer Easy C++ To Do To Do 008 String to Integer (atoi) Medium To Do To Do To Do 009 Palindrome Number Easy C++ To Do solution 010 Regular Expression Matching Hard To Do To Do To Do 011 Container With Most Water Medium To Do To Do To Do 012 Integer to Roman Medium To Do To Do To Do 013 Roman to Integer Easy C++ To Do To Do 014 Longest Common Prefix Easy To Do To Do To Do 015 3Sum Medium C++ To Do solution 016 3Sum Closest Medium C++ To Do solution 017 Letter Combinations of a Phone Number Medium To Do To Do To Do 018 4Sum Medium C++ To Do solution 019 Remove Nth Node From End of List Medium To Do To Do To Do 020 Valid Parentheses Easy To Do To Do To Do 021 Merge Two Sorted Lists Easy C++ To Do solution 022 Generate Parentheses Medium C++ To Do To Do 023 Merge k Sorted Lists Hard To Do To Do To Do 024 Swap Nodes in Pairs Medium C++ To Do To Do 025 Reverse Nodes in k-Group Hard To Do To Do To Do 026 Remove Duplicates from Sorted Array Easy C++ To Do solution 027 Remove Element Easy C++ To Do solution 028 Implement strStr() Easy C++ To Do To Do 029 Divide Two Integers Medium To Do To Do To Do 030 Substring with Concatenation of All Words Hard To Do To Do To Do 031 Next Permutation Medium C++ To Do solution 032 Longest Valid Parentheses Hard To Do To Do To Do 033 Search in Rotated Sorted Array Medium To Do To Do To Do 034 Search for a Range Medium C++ To Do solution 035 Search Insert Position Easy C++ To Do solution 036 Valid Sudoku Medium To Do To Do To Do 037 Sudoku Solver Hard To Do To Do To Do 038 Count and Say Easy To Do To Do To Do 039 Combination Sum Medium C++ To Do solution 040 Combination Sum II Medium To Do To Do To Do 041 First Missing Positive Hard To Do To Do To Do 042 Trapping Rain Water Hard To Do To Do To Do 043 Multiply Strings Medium To Do To Do To Do 044 Wildcard Matching Hard To Do To Do To Do 045 Jump Game II Hard To Do To Do To Do 046 Permutations Medium To Do To Do To Do 047 Permutations II Medium To Do To Do To Do 048 Rotate Image Medium To Do To Do To Do 049 Group Anagrams Medium To Do To Do To Do 050 Pow(x, n) Medium C++ To Do To Do 051 N-Queens Hard To Do To Do To Do 052 N-Queens II Hard To Do To Do To Do 053 Maximum Subarray Easy To Do To Do To Do 054 Spiral Matrix Medium To Do To Do To Do 055 Jump Game Medium C++ To Do solution 056 Merge Intervals Medium To Do To Do To Do 057 Insert Interval Hard To Do To Do To Do 058 Length of Last Word Easy To Do To Do To Do 059 Spiral Matrix II Medium C++ To Do To Do 060 Permutation Sequence Medium To Do To Do To Do 061 Rotate List Medium To Do To Do To Do 062 Unique Paths Medium To Do To Do To Do 063 Unique Paths II Medium To Do To Do To Do 064 Minimum Path Sum Medium To Do To Do To Do 065 Valid Number Hard To Do To Do To Do 066 Plus One Easy C++ To Do solution 067 Add Binary Easy C++ To Do solution 068 Text Justification Hard To Do To Do To Do 069 Sqrt(x) Easy C++ To Do To Do 070 Climbing Stairs Easy To Do To Do To Do 071 Simplify Path Medium To Do To Do To Do 072 Edit Distance Hard To Do To Do To Do 073 Set Matrix Zeroes Medium To Do To Do To Do 074 Search a 2D Matrix Medium C++ To Do solution 075 Sort Colors Medium To Do To Do To Do 076 Minimum Window Substring Hard To Do To Do To Do 077 Combinations Medium To Do To Do To Do 078 Subsets Medium To Do To Do To Do 079 Word Search Medium To Do To Do To Do 080 Remove Duplicates from Sorted Array II Medium C++ To Do solution 081 Search in Rotated Sorted Array II Medium To Do To Do To Do 082 Remove Duplicates from Sorted List II Medium To Do To Do To Do 083 Remove Duplicates from Sorted List Easy To Do To Do To Do 084 Largest Rectangle in Histogram Hard C++ To Do solution 085 Maximal Rectangle Hard C++ To Do solution 086 Partition List Medium To Do To Do To Do 087 Scramble String Hard To Do To Do To Do 088 Merge Sorted Array Easy C++ To Do To Do 089 Gray Code Medium C++ To Do To Do 090 Subsets II Medium To Do To Do To Do 091 Decode Ways Medium To Do To Do To Do 092 Reverse Linked List II Medium To Do To Do To Do 093 Restore IP Addresses Medium To Do To Do To Do 094 Binary Tree Inorder Traversal Medium To Do To Do To Do 095 Unique Binary Search Trees II Medium To Do To Do To Do 096 Unique Binary Search Trees Medium C++ To Do solution 097 Interleaving String Hard To Do To Do To Do 098 Validate Binary Search Tree Medium C++ To Do solution 099 Recover Binary Search Tree Hard C++ To Do solution 100 Same Tree Easy C++ To Do solution 101 Symmetric Tree Easy C++ To Do solution 102 Binary Tree Level Order Traversal Medium C++ To Do solution 103 Binary Tree Zigzag Level Order Traversal Medium C++ To Do solution 104 Maximum Depth of Binary Tree Easy C++ To Do solution 105 Construct Binary Tree from Preorder and Inorder Traversal Medium C++ To Do solution 106 Construct Binary Tree from Inorder and Postorder Traversal Medium C++ To Do solution 107 Binary Tree Level Order Traversal II Easy C++ To Do solution 108 Convert Sorted Array to Binary Search Tree Easy To Do To Do To Do 109 Convert Sorted List to Binary Search Tree Medium To Do To Do To Do 110 Balanced Binary Tree Easy C++ To Do solution 111 Minimum Depth of Binary Tree Easy C++ To Do solution 112 Path Sum Easy C++ To Do solution 113 Path Sum II Medium C++ To Do solution 114 Flatten Binary Tree to Linked List Medium C++ To Do solution 115 Distinct Subsequences Hard To Do To Do To Do 116 Populating Next Right Pointers in Each Node Medium C++ To Do solution 117 Populating Next Right Pointers in Each Node II Medium C++ To Do solution 118 Pascal’s Triangle Easy C++ To Do solution 119 Pascal’s Triangle II Easy C++ To Do solution 120 Triangle Medium To Do To Do To Do 121 Best Time to Buy and Sell Stock Easy To Do To Do To Do 122 Best Time to Buy and Sell Stock II Easy To Do To Do To Do 123 Best Time to Buy and Sell Stock III Hard To Do To Do To Do 124 Binary Tree Maximum Path Sum Hard To Do To Do To Do 125 Valid Palindrome Easy C++ To Do solution 126 Word Ladder II Hard To Do To Do To Do 127 Word Ladder Medium To Do To Do To Do 128 Longest Consecutive Sequence Hard To Do To Do To Do 129 Sum Root to Leaf Numbers Medium C++ To Do solution 130 Surrounded Regions Medium To Do To Do To Do 131 Palindrome Partitioning Medium To Do To Do To Do 132 Palindrome Partitioning II Hard To Do To Do To Do 133 Clone Graph Medium To Do To Do To Do 134 Gas Station Medium To Do To Do To Do 135 Candy Hard To Do To Do To Do 136 Single Number Easy C++ To Do To Do 137 Single Number II Medium To Do To Do To Do 138 Copy List with Random Pointer Medium To Do To Do To Do 139 Word Break Medium To Do To Do To Do 140 Word Break II Hard To Do To Do To Do 141 Linked List Cycle Easy C++ To Do To Do 142 Linked List Cycle II Medium To Do To Do To Do 143 Reorder List Medium To Do To Do To Do 144 Binary Tree Preorder Traversal Medium To Do To Do To Do 145 Binary Tree Postorder Traversal Hard To Do To Do To Do 146 LRU Cache Hard To Do To Do To Do 147 Insertion Sort List Medium To Do To Do To Do 148 Sort List Medium To Do To Do To Do 149 Max Points on a Line Hard To Do To Do To Do 150 Evaluate Reverse Polish Notation Medium To Do To Do To Do 151 Reverse Words in a String Medium To Do To Do To Do 152 Maximum Product Subarray Medium C++ To Do To Do 153 Find Minimum in Rotated Sorted Array Medium C++ To Do solution 154 Find Minimum in Rotated Sorted Array II Hard C++ To Do solution 155 Min Stack Easy C++ To Do solution 156 Binary Tree Upside Down :lock: Medium To Do To Do To Do 157 Read N Characters Given Read4 :lock: Easy To Do To Do To Do 158 Read N Characters Given Read4 II - Call multiple times :lock: Hard To Do To Do To Do 159 Longest Substring with At Most Two Distinct Characters :lock: Hard To Do To Do To Do 160 Intersection of Two Linked Lists Easy To Do To Do To Do 161 One Edit Distance :lock: Medium To Do To Do solution 162 Find Peak Element Medium C++ To Do solution 163 Missing Ranges :lock: Medium To Do To Do To Do 164 Maximum Gap Hard To Do To Do To Do 165 Compare Version Numbers Medium C++ To Do To Do 166 Fraction to Recurring Decimal Medium C++ To Do solution 167 Two Sum II - Input array is sorted Easy C++ To Do To Do 168 Excel Sheet Column Title Easy To Do To Do To Do 169 Majority Element Easy To Do To Do To Do 170 Two Sum III - Data structure design :lock: Easy To Do To Do To Do 171 Excel Sheet Column Number Easy C++ To Do solution 172 Factorial Trailing Zeroes Easy C++ Python solution 173 Binary Search Tree Iterator Medium C++ To Do solution 174 Dungeon Game Hard To Do To Do To Do 179 Largest Number Medium C++ To Do To Do 186 Reverse Words in a String II :lock: Medium To Do To Do To Do 187 Repeated DNA Sequences Medium To Do To Do To Do 188 Best Time to Buy and Sell Stock IV Hard To Do To Do To Do 189 Rotate Array Easy To Do To Do To Do 190 Reverse Bits Easy To Do To Do To Do 191 Number of 1 Bits Easy C++ To Do solution 198 House Robber Easy To Do To Do To Do 199 Binary Tree Right Side View Medium To Do To Do To Do 200 Number of Islands Medium To Do To Do To Do 201 Bitwise AND of Numbers Range Medium To Do To Do To Do 202 Happy Number Easy To Do To Do To Do 203 Remove Linked List Elements Easy To Do To Do To Do 204 Count Primes Easy C++ To Do To Do 205 Isomorphic Strings Easy To Do To Do To Do 206 Reverse Linked List Easy To Do To Do To Do 207 Course Schedule Medium To Do To Do To Do 208 Implement Trie (Prefix Tree) Medium C++ To Do To Do 209 Minimum Size Subarray Sum Medium C++ To Do solution 210 Course Schedule II Medium To Do To Do To Do 211 Add and Search Word - Data structure design Medium To Do To Do To Do 212 Word Search II Hard To Do To Do To Do 213 House Robber II Medium To Do To Do To Do 214 Shortest Palindrome Hard To Do To Do To Do 215 Kth Largest Element in an Array Medium C++ To Do solution 216 Combination Sum III Medium To Do To Do To Do 217 Contains Duplicate Easy To Do To Do To Do 218 The Skyline Problem Hard To Do To Do To Do 219 Contains Duplicate II Easy To Do To Do To Do 220 Contains Duplicate III Medium To Do To Do To Do 221 Maximal Square Medium C++ To Do To Do 222 Count Complete Tree Nodes Medium To Do To Do To Do 223 Rectangle Area Medium To Do To Do To Do 224 Basic Calculator Hard To Do To Do To Do 225 Implement Stack using Queues Easy To Do To Do To Do 226 Invert Binary Tree Easy To Do To Do To Do 227 Basic Calculator II Medium C++ To Do solution 228 Summary Ranges Medium To Do To Do To Do 229 Majority Element II Medium To Do To Do To Do 230 Kth Smallest Element in a BST Medium To Do To Do To Do 231 Power of Two Easy C++ To Do solution 232 Implement Queue using Stacks Easy To Do To Do To Do 233 Number of Digit One Hard C++ To Do To Do 234 Palindrome Linked List Easy To Do To Do To Do 235 Lowest Common Ancestor of a Binary Search Tree Easy To Do To Do To Do 236 Lowest Common Ancestor of a Binary Tree Medium To Do To Do To Do 237 Delete Node in a Linked List Easy To Do To Do To Do 238 Product of Array Except Self Medium To Do To Do To Do 239 Sliding Window Maximum Hard To Do To Do To Do 240 Search a 2D Matrix II Medium To Do To Do To Do 241 Different Ways to Add Parentheses Medium To Do To Do To Do 242 Valid Anagram Easy C++ To Do To Do 243 Shortest Word Distance :lock: Easy To Do To Do To Do 244 Shortest Word Distance II :lock: Medium To Do To Do To Do 245 Shortest Word Distance III :lock: Medium To Do To Do To Do 246 Strobogrammatic Number :lock: Easy To Do To Do To Do 247 Strobogrammatic Number II :lock: Medium To Do To Do To Do 248 Strobogrammatic Number III :lock: Hard To Do To Do To Do 249 Group Shifted Strings :lock: Medium To Do To Do To Do 250 Count Univalue Subtrees :lock: Medium To Do To Do To Do 251 Flatten 2D Vector :lock: Medium To Do To Do To Do 252 Meeting Rooms :lock: Easy To Do To Do To Do 253 Meeting Rooms II :lock: Medium To Do To Do To Do 254 Factor Combinations :lock: Medium To Do To Do To Do 255 Verify Preorder Sequence in Binary Search Tree :lock: Medium To Do To Do To Do 256 Paint House :lock: Easy To Do To Do To Do 257 Binary Tree Paths Easy C++ To Do solution 258 Add Digits Easy To Do To Do To Do 259 3Sum Smaller :lock: Medium To Do To Do To Do 260 Single Number III Medium C++ To Do To Do 261 Graph Valid Tree :lock: Medium To Do To Do To Do 263 Ugly Number Easy C++ To Do To Do 264 Ugly Number II Medium To Do To Do To Do 265 Paint House II :lock: Hard To Do To Do To Do 266 Palindrome Permutation :lock: Easy To Do To Do To Do 267 Palindrome Permutation II :lock: Medium To Do To Do To Do 268 Missing Number Easy C++ To Do solution 269 Alien Dictionary :lock: Hard To Do To Do To Do 270 Closest Binary Search Tree Value :lock: Easy To Do To Do To Do 271 Encode and Decode Strings :lock: Medium To Do To Do To Do 272 Closest Binary Search Tree Value II :lock: Hard To Do To Do To Do 273 Integer to English Words Hard To Do To Do To Do 274 H-Index Medium To Do To Do To Do 275 H-Index II Medium To Do To Do To Do 276 Paint Fence :lock: Easy To Do To Do To Do 277 Find the Celebrity :lock: Medium To Do To Do To Do 278 First Bad Version Easy To Do To Do To Do 279 Perfect Squares Medium C++ To Do solution 280 Wiggle Sort :lock: Medium To Do To Do To Do 281 Zigzag Iterator :lock: Medium To Do To Do To Do 282 Expression Add Operators Hard C++ To Do solution 283 Move Zeroes Easy To Do To Do To Do 284 Peeking Iterator Medium To Do To Do To Do 285 Inorder Successor in BST :lock: Medium To Do To Do To Do 286 Walls and Gates :lock: Medium To Do To Do To Do 287 Find the Duplicate Number Medium To Do To Do To Do 288 Unique Word Abbreviation :lock: Medium To Do To Do To Do 289 Game of Life Medium To Do To Do To Do 290 Word Pattern Easy To Do To Do To Do 291 Word Pattern II :lock: Hard To Do To Do To Do 292 Nim Game Easy C++ To Do To Do 293 Flip Game :lock: Easy To Do To Do To Do 294 Flip Game II :lock: Medium To Do To Do To Do 295 Find Median from Data Stream Hard To Do To Do To Do 296 Best Meeting Point :lock: Hard To Do To Do To Do 297 Serialize and Deserialize Binary Tree Hard To Do To Do To Do 298 Binary Tree Longest Consecutive Sequence :lock: Medium To Do To Do To Do 299 Bulls and Cows Medium C++ To Do To Do 300 Longest Increasing Subsequence Medium To Do To Do To Do 301 Remove Invalid Parentheses Hard To Do To Do To Do 302 Smallest Rectangle Enclosing Black Pixels :lock: Hard To Do To Do To Do 303 Range Sum Query - Immutable Easy C++ To Do To Do 304 Range Sum Query 2D - Immutable Medium To Do To Do To Do 305 Number of Islands II :lock: Hard To Do To Do To Do 306 Additive Number Medium To Do To Do To Do 307 Range Sum Query - Mutable Medium C++ To Do To Do 308 Range Sum Query 2D - Mutable :lock: Hard To Do To Do To Do 309 Best Time to Buy and Sell Stock with Cooldown Medium To Do To Do To Do 310 Minimum Height Trees Medium To Do To Do To Do 311 Sparse Matrix Multiplication :lock: Medium To Do To Do To Do 312 Burst Balloons Hard To Do To Do To Do 313 Super Ugly Number Medium To Do To Do To Do 314 Binary Tree Vertical Order Traversal :lock: Medium To Do To Do To Do 315 Count of Smaller Numbers After Self Hard To Do To Do To Do 316 Remove Duplicate Letters Hard To Do To Do To Do 317 Shortest Distance from All Buildings :lock: Hard To Do To Do To Do 318 Maximum Product of Word Lengths Medium To Do To Do To Do 319 Bulb Switcher Medium To Do To Do To Do 320 Generalized Abbreviation :lock: Medium To Do To Do To Do 321 Create Maximum Number Hard To Do To Do To Do 322 Coin Change Medium To Do To Do To Do 323 Number of Connected Components in an Undirected Graph :lock: Medium To Do To Do To Do 324 Wiggle Sort II Medium To Do To Do To Do 325 Maximum Size Subarray Sum Equals k :lock: Medium To Do To Do To Do 326 Power of Three Easy To Do To Do To Do 327 Count of Range Sum Hard To Do To Do To Do 328 Odd Even Linked List Medium To Do To Do To Do 329 Longest Increasing Path in a Matrix Hard C++ To Do To Do 330 Patching Array Hard To Do To Do To Do 331 Verify Preorder Serialization of a Binary Tree Medium C++ To Do solution 332 Reconstruct Itinerary Medium To Do To Do To Do 333 Largest BST Subtree :lock: Medium To Do To Do To Do 334 Increasing Triplet Subsequence Medium To Do To Do To Do 335 Self Crossing Hard To Do To Do To Do 336 Palindrome Pairs Hard To Do To Do To Do 337 House Robber III Medium C++ To Do solution 338 Counting Bits Medium C++ To Do To Do 339 Nested List Weight Sum :lock: Easy To Do To Do To Do 340 Longest Substring with At Most K Distinct Characters :lock: Hard To Do To Do To Do 341 Flatten Nested List Iterator Medium To Do To Do To Do 342 Power of Four Easy To Do To Do To Do 343 Integer Break Medium To Do To Do To Do 344 Reverse String Easy C++ To Do To Do 345 Reverse Vowels of a String Easy To Do To Do To Do 346 Moving Average from Data Stream :lock: Easy To Do To Do To Do 347 Top K Frequent Elements Medium To Do To Do To Do 348 Design Tic-Tac-Toe :lock: Medium To Do To Do To Do 349 Intersection of Two Arrays Easy C++ To Do To Do 350 Intersection of Two Arrays II Easy To Do To Do To Do 351 Android Unlock Patterns :lock: Medium To Do To Do To Do 352 Data Stream as Disjoint Intervals Hard To Do To Do To Do 353 Design Snake Game :lock: Medium To Do To Do To Do 354 Russian Doll Envelopes Hard To Do To Do To Do 355 Design Twitter Medium To Do To Do To Do 356 Line Reflection :lock: Medium To Do To Do To Do 357 Count Numbers with Unique Digits Medium C++ To Do To Do 358 Rearrange String k Distance Apart :lock: Hard To Do To Do To Do 359 Logger Rate Limiter :lock: Easy To Do To Do To Do 360 Sort Transformed Array :lock: Medium To Do To Do To Do 361 Bomb Enemy :lock: Medium To Do To Do To Do 362 Design Hit Counter :lock: Medium To Do To Do To Do 363 Max Sum of Rectangle No Larger Than K Hard C++ To Do To Do 364 Nested List Weight Sum II :lock: Medium To Do To Do To Do 365 Water and Jug Problem Medium To Do To Do To Do 366 Find Leaves of Binary Tree :lock: Medium To Do To Do To Do 367 Valid Perfect Square Easy To Do To Do To Do 368 Largest Divisible Subset Medium C++ To Do To Do 369 Plus One Linked List :lock: Medium To Do To Do To Do 370 Range Addition :lock: Medium To Do To Do To Do 371 Sum of Two Integers Easy C++ To Do To Do 372 Super Pow Medium To Do To Do To Do 373 Find K Pairs with Smallest Sums Medium To Do To Do To Do 374 Guess Number Higher or Lower Easy C++ To Do To Do 375 Guess Number Higher or Lower II Medium To Do To Do To Do 376 Wiggle Subsequence Medium C++ To Do To Do 377 Combination Sum IV Medium To Do To Do To Do 378 Kth Smallest Element in a Sorted Matrix Medium To Do To Do To Do 379 Design Phone Directory :lock: Medium To Do To Do To Do 380 Insert Delete GetRandom O(1) Medium To Do To Do To Do 381 Insert Delete GetRandom O(1) - Duplicates allowed Hard To Do To Do To Do 382 Linked List Random Node Medium To Do To Do To Do 383 Ransom Note Easy To Do To Do To Do 384 Shuffle an Array Medium C++ To Do To Do 385 Mini Parser Medium To Do To Do To Do 386 Lexicographical Numbers Medium To Do To Do To Do 387 First Unique Character in a String Easy C++ To Do To Do 388 Longest Absolute File Path Medium To Do To Do To Do 389 Find the Difference Easy To Do To Do To Do 390 Elimination Game Medium C++ To Do To Do 391 Perfect Rectangle Hard To Do To Do To Do 392 Is Subsequence Medium To Do To Do To Do 393 UTF-8 Validation Medium To Do To Do To Do 394 Decode String Medium To Do To Do To Do 395 Longest Substring with At Least K Repeating Characters Medium C++ To Do To Do 396 Rotate Function Medium To Do To Do To Do 397 Integer Replacement Medium C++ To Do solution 398 Random Pick Index Medium To Do To Do To Do 399 Evaluate Division Medium C++ To Do To Do 400 Nth Digit Easy To Do To Do To Do 401 Binary Watch Easy C++ To Do To Do 402 Remove K Digits Medium To Do To Do To Do 403 Frog Jump Hard To Do To Do To Do 404 Sum of Left Leaves Easy C++ To Do solution 405 Convert a Number to Hexadecimal Easy To Do To Do To Do 406 Queue Reconstruction by Height Medium To Do To Do To Do 407 Trapping Rain Water II Hard To Do To Do To Do 408 Valid Word Abbreviation :lock: Easy To Do To Do To Do 409 Longest Palindrome Easy To Do To Do To Do 410 Split Array Largest Sum Hard C++ To Do To Do 411 Minimum Unique Word Abbreviation :lock: Hard To Do To Do To Do 412 Fizz Buzz Easy To Do To Do To Do 413 Arithmetic Slices Medium To Do To Do To Do 414 Third Maximum Number Easy To Do To Do To Do 415 Add Strings Easy To Do To Do To Do 416 Partition Equal Subset Sum Medium To Do To Do To Do 417 Pacific Atlantic Water Flow Medium To Do To Do To Do 418 Sentence Screen Fitting :lock: Medium To Do To Do To Do 419 Battleships in a Board Medium To Do To Do To Do 420 Strong Password Checker Hard To Do To Do To Do 421 Maximum XOR of Two Numbers in an Array Medium To Do To Do To Do 422 Valid Word Square :lock: Easy To Do To Do To Do 423 Reconstruct Original Digits from English Medium To Do To Do To Do 424 Longest Repeating Character Replacement Medium To Do To Do To Do 425 Word Squares :lock: Hard To Do To Do To Do 432 All O`one Data Structure Hard To Do To Do To Do 434 Number of Segments in a String Easy C++ To Do To Do 435 Non-overlapping Intervals Medium To Do To Do To Do 436 Find Right Interval Medium To Do To Do To Do 437 Path Sum III Easy To Do To Do To Do 438 Find All Anagrams in a String Easy To Do To Do To Do 439 Ternary Expression Parser :lock: Medium To Do To Do To Do 440 K-th Smallest in Lexicographical Order Hard To Do To Do To Do 441 Arranging Coins Easy To Do To Do To Do 442 Find All Duplicates in an Array Medium C++ To Do To Do 443 String Compression Easy To Do To Do To Do 444 Sequence Reconstruction :lock: Medium To Do To Do To Do 445 Add Two Numbers II Medium C++ To Do To Do 446 Arithmetic Slices II - Subsequence Hard To Do To Do To Do 447 Number of Boomerangs Easy C++ To Do To Do 448 Find All Numbers Disappeared in an Array Easy To Do To Do To Do 449 Serialize and Deserialize BST Medium To Do To Do To Do 450 Delete Node in a BST Medium To Do To Do To Do 451 Sort Characters By Frequency Medium To Do To Do To Do 452 Minimum Number of Arrows to Burst Balloons Medium To Do To Do To Do 453 Minimum Moves to Equal Array Elements Easy To Do To Do To Do 454 4Sum II Medium To Do To Do To Do 455 Assign Cookies Easy C++ To Do To Do 456 132 Pattern Medium To Do To Do To Do 459 Repeated Substring Pattern Easy To Do To Do To Do 460 LFU Cache Hard To Do To Do To Do 461 Hamming Distance Easy C++ To Do To Do 462 Minimum Moves to Equal Array Elements II Medium C++ To Do To Do 463 Island Perimeter Easy To Do To Do To Do 464 Can I Win Medium To Do To Do To Do 465 Optimal Account Balancing :lock: Hard To Do To Do To Do 466 Count The Repetitions Hard To Do To Do To Do 467 Unique Substrings in Wraparound String Medium To Do To Do To Do 468 Validate IP Address Medium To Do To Do To Do 469 Convex Polygon :lock: Medium To Do To Do To Do 471 Encode String with Shortest Length :lock: Hard To Do To Do To Do 472 Concatenated Words Hard To Do To Do To Do 473 Matchsticks to Square Medium C++ To Do solution 474 Ones and Zeroes Medium To Do To Do To Do 475 Heaters Easy To Do To Do To Do 476 Number Complement Easy To Do To Do To Do 477 Total Hamming Distance Medium To Do To Do To Do 479 Largest Palindrome Product Easy To Do To Do To Do 480 Sliding Window Median Hard To Do To Do To Do 481 Magical String Medium To Do To Do To Do 482 License Key Formatting Easy To Do To Do To Do 483 Smallest Good Base Hard To Do To Do To Do 484 Find Permutation :lock: Medium To Do To Do To Do 485 Max Consecutive Ones Easy C++ To Do To Do 486 Predict the Winner Medium To Do To Do To Do 487 Max Consecutive Ones II :lock: Medium To Do To Do To Do 488 Zuma Game Hard To Do To Do To Do 490 The Maze :lock: Medium To Do To Do To Do 491 Increasing Subsequences Medium To Do To Do To Do 492 Construct the Rectangle Easy To Do To Do To Do 493 Reverse Pairs Hard To Do To Do To Do 494 Target Sum Medium To Do To Do To Do 495 Teemo Attacking Medium To Do To Do To Do 496 Next Greater Element I Easy To Do To Do To Do 498 Diagonal Traverse Medium To Do To Do To Do 499 The Maze III :lock: Hard To Do To Do To Do 500 Keyboard Row Easy C++ To Do To Do 501 Find Mode in Binary Search Tree Easy C++ To Do To Do 502 IPO Hard To Do To Do To Do 503 Next Greater Element II Medium To Do To Do To Do 504 Base 7 Easy C++ To Do To Do 505 The Maze II :lock: Medium To Do To Do To Do 506 Relative Ranks Easy To Do To Do To Do 507 Perfect Number Easy To Do To Do To Do 508 Most Frequent Subtree Sum Medium To Do To Do To Do 513 Find Bottom Left Tree Value Medium To Do To Do To Do 514 Freedom Trail Hard To Do To Do To Do 515 Find Largest Value in Each Tree Row Medium To Do To Do To Do 516 Longest Palindromic Subsequence Medium To Do To Do To Do 517 Super Washing Machines Hard To Do To Do To Do 520 Detect Capital Easy C++ To Do To Do 521 Longest Uncommon Subsequence I Easy To Do To Do To Do 522 Longest Uncommon Subsequence II Medium To Do To Do To Do 523 Continuous Subarray Sum Medium To Do To Do To Do 524 Longest Word in Dictionary through Deleting Medium To Do To Do To Do 525 Contiguous Array Medium To Do To Do To Do 526 Beautiful Arrangement Medium To Do To Do To Do 527 Word Abbreviation :lock: Hard To Do To Do To Do 529 Minesweeper Medium To Do To Do To Do 530 Minimum Absolute Difference in BST Easy C++ To Do To Do 531 Lonely Pixel I :lock: Medium To Do To Do To Do 532 K-diff Pairs in an Array Easy C++ To Do solution 533 Lonely Pixel II :lock: Medium To Do To Do To Do 535 Encode and Decode TinyURL Medium To Do To Do To Do 536 Construct Binary Tree from String :lock: Medium To Do To Do To Do 537 Complex Number Multiplication Medium To Do To Do To Do 538 Convert BST to Greater Tree Easy C++ To Do To Do 539 Minimum Time Difference Medium To Do To Do To Do 540 Single Element in a Sorted Array Medium To Do To Do To Do 541 Reverse String II Easy To Do To Do To Do 542 01 Matrix Medium To Do To Do To Do 543 Diameter of Binary Tree Easy To Do To Do To Do 544 Output Contest Matches :lock: Medium To Do To Do To Do 545 Boundary of Binary Tree :lock: Medium To Do To Do To Do 546 Remove Boxes Hard To Do To Do To Do 547 Friend Circles Medium To Do To Do To Do 548 Split Array with Equal Sum :lock: Medium To Do To Do To Do 549 Binary Tree Longest Consecutive Sequence II :lock: Medium To Do To Do To Do 551 Student Attendance Record I Easy C++ To Do To Do 552 Student Attendance Record II Hard To Do To Do To Do 553 Optimal Division Medium To Do To Do To Do 554 Brick Wall Medium To Do To Do To Do 555 Split Concatenated Strings :lock: Medium To Do To Do To Do 556 Next Greater Element III Medium To Do To Do To Do 557 Reverse Words in a String III Easy C++ To Do To Do 560 Subarray Sum Equals K Medium To Do To Do To Do 561 Array Partition I Easy To Do To Do To Do 562 Longest Line of Consecutive One in Matrix :lock: Medium To Do To Do To Do 563 Binary Tree Tilt Easy To Do To Do To Do 564 Find the Closest Palindrome Hard To Do To Do To Do 565 Array Nesting Medium To Do To Do To Do 566 Reshape the Matrix Easy To Do To Do To Do 567 Permutation in String Medium To Do To Do To Do 568 Maximum Vacation Days :lock: Hard To Do To Do To Do 572 Subtree of Another Tree Easy To Do To Do To Do 573 Squirrel Simulation :lock: Medium To Do To Do To Do 575 Distribute Candies Easy To Do To Do To Do 576 Out of Boundary Paths Medium To Do To Do To Do 581 Shortest Unsorted Continuous Subarray Easy To Do To Do To Do 582 Kill Process :lock: Medium To Do To Do To Do 583 Delete Operation for Two Strings Medium C++ To Do To Do 587 Erect the Fence Hard To Do To Do To Do 588 Design In-Memory File System :lock: Hard To Do To Do To Do 591 Tag Validator Hard To Do To Do To Do 592 Fraction Addition and Subtraction Medium To Do To Do To Do 593 Valid Square Medium To Do To Do To Do 594 Longest Harmonious Subsequence Easy To Do To Do To Do 598 Range Addition II Easy To Do To Do To Do 599 Minimum Index Sum of Two Lists Easy To Do To Do To Do 600 Non-negative Integers without Consecutive Ones Hard To Do To Do To Do 604 Design Compressed String Iterator :lock: Easy To Do To Do To Do 605 Can Place Flowers Easy C++ To Do To Do 606 Construct String from Binary Tree Easy To Do To Do To Do 609 Find Duplicate File in System Medium To Do To Do To Do 611 Valid Triangle Number Medium C++ To Do solution 616 Add Bold Tag in String :lock: Medium To Do To Do To Do 617 Merge Two Binary Trees Easy To Do To Do To Do 621 Task Scheduler Medium To Do To Do To Do 623 Add One Row to Tree Medium To Do To Do To Do 624 Maximum Distance in Arrays :lock: Easy To Do To Do To Do 625 Minimum Factorization :lock: Medium To Do To Do To Do 628 Maximum Product of Three Numbers Easy C++ To Do To Do 629 K Inverse Pairs Array Hard To Do To Do To Do 630 Course Schedule III Hard To Do To Do To Do 631 Design Excel Sum Formula :lock: Hard To Do To Do To Do 632 Smallest Range Hard C++ To Do To Do 633 Sum of Square Numbers Easy To Do To Do To Do 634 Find the Derangement of An Array :lock: Medium To Do To Do To Do 635 Design Log Storage System :lock: Medium To Do To Do To Do 636 Exclusive Time of Functions Medium To Do To Do To Do 637 Average of Levels in Binary Tree Easy To Do To Do To Do 638 Shopping Offers Medium To Do To Do To Do 639 Decode Ways II Hard To Do To Do To Do 640 Solve the Equation Medium To Do To Do To Do 642 Design Search Autocomplete System :lock: Hard To Do To Do To Do 643 Maximum Average Subarray I Easy To Do To Do To Do 644 Maximum Average Subarray II :lock: Hard To Do To Do To Do 645 Set Mismatch Easy To Do To Do To Do 646 Maximum Length of Pair Chain Medium To Do To Do To Do 647 Palindromic Substrings Medium C++ To Do To Do 648 Replace Words Medium C++ To Do To Do 649 Dota2 Senate Medium To Do To Do To Do 650 2 Keys Keyboard Medium To Do To Do To Do 651 4 Keys Keyboard :lock: Medium To Do To Do To Do 652 Find Duplicate Subtrees Medium To Do To Do To Do 653 Two Sum IV - Input is a BST Easy To Do To Do To Do 654 Maximum Binary Tree Medium To Do To Do To Do 655 Print Binary Tree Medium To Do To Do To Do 656 Coin Path :lock: Hard To Do To Do To Do 657 Judge Route Circle Easy To Do To Do To Do 658 Find K Closest Elements Medium To Do To Do To Do 659 Split Array into Consecutive Subsequences Medium To Do To Do To Do 660 Remove 9 :lock: Hard To Do To Do To Do 661 Image Smoother Easy To Do To Do To Do 662 Maximum Width of Binary Tree Medium To Do To Do To Do 663 Equal Tree Partition :lock: Medium To Do To Do To Do 664 Strange Printer Hard To Do To Do To Do 665 Non-decreasing Array Easy To Do To Do To Do 666 Path Sum IV :lock: Medium To Do To Do To Do 667 Beautiful Arrangement II Medium To Do To Do To Do 668 Kth Smallest Number in Multiplication Table Hard To Do To Do To Do 669 Trim a Binary Search Tree Easy To Do To Do To Do 670 Maximum Swap Medium To Do To Do To Do 671 Second Minimum Node In a Binary Tree Easy To Do To Do To Do 672 Bulb Switcher II Medium To Do To Do To Do 673 Number of Longest Increasing Subsequence Medium To Do To Do To Do 674 Longest Continuous Increasing Subsequence Easy To Do To Do To Do 675 Cut Off Trees for Golf Event Hard To Do To Do To Do 676 Implement Magic Dictionary Medium To Do To Do To Do 677 Map Sum Pairs Medium To Do To Do To Do 678 Valid Parenthesis String Medium To Do To Do To Do 679 24 Game Hard To Do To Do To Do 680 Valid Palindrome II Easy To Do To Do To Do 681 Next Closest Time :lock: Medium To Do To Do To Do 682 Baseball Game Easy To Do To Do To Do 683 K Empty Slots :lock: Hard To Do To Do To Do 684 Redundant Connection Medium To Do To Do To Do 685 Redundant Connection II Hard To Do To Do To Do 686 Repeated String Match Easy To Do To Do To Do 687 Longest Univalue Path Easy C++ To Do solution 688 Knight Probability in Chessboard Medium To Do To Do To Do 689 Maximum Sum of 3 Non-Overlapping Subarrays Hard To Do To Do To Do 690 Employee Importance Easy To Do To Do To Do 691 Stickers to Spell Word Hard To Do To Do To Do 692 Top K Frequent Words Medium To Do To Do To Do 693 Binary Number with Alternating Bits Easy To Do To Do To Do 694 Number of Distinct Islands :lock: Medium To Do To Do To Do 695 Max Area of Island Easy To Do To Do To Do 696 Count Binary Substrings Easy To Do To Do To Do 697 Degree of an Array Easy To Do To Do To Do 698 Partition to K Equal Sum Subsets Medium To Do To Do To Do 699 Falling Squares Hard To Do To Do To Do 711 Number of Distinct Islands II :lock: Hard To Do To Do To Do 712 Minimum ASCII Delete Sum for Two Strings Medium To Do To Do To Do 713 Subarray Product Less Than K Medium To Do To Do To Do 714 Best Time to Buy and Sell Stock with Transaction Fee Medium To Do To Do To Do 715 Range Module Hard To Do To Do To Do 716 Max Stack :lock: Hard To Do To Do To Do 717 1-bit and 2-bit Characters Easy To Do To Do To Do 718 Maximum Length of Repeated Subarray Medium To Do To Do To Do 719 Find K-th Smallest Pair Distance Hard To Do To Do To Do 720 Longest Word in Dictionary Easy To Do To Do To Do 721 Accounts Merge Medium To Do To Do To Do 722 Remove Comments Medium To Do To Do To Do 723 Candy Crush :lock: Medium To Do To Do To Do 724 Find Pivot Index Easy To Do To Do To Do 725 Split Linked List in Parts Medium To Do To Do To Do 726 Number of Atoms Hard To Do To Do To Do 727 Minimum Window Subsequence :lock: Hard To Do To Do To Do 728 Self Dividing Numbers Easy To Do To Do To Do 729 My Calendar I Medium To Do To Do To Do 730 Count Different Palindromic Subsequences Hard To Do To Do To Do 731 My Calendar II Medium To Do To Do To Do 732 My Calendar III Hard To Do To Do To Do 733 Flood Fill Easy To Do To Do To Do 734 Sentence Similarity :lock: Easy To Do To Do To Do 735 Asteroid Collision Medium To Do To Do To Do 736 Parse Lisp Expression Hard To Do To Do To Do 737 Sentence Similarity II :lock: Medium To Do To Do To Do 738 Monotone Increasing Digits Medium To Do To Do To Do 739 Daily Temperatures Medium To Do To Do To Do 740 Delete and Earn Medium To Do To Do To Do 741 Cherry Pickup Hard To Do To Do To Do 742 Closest Leaf in a Binary Tree :lock: Medium To Do To Do To Do 743 Network Delay Time Medium To Do To Do To Do 744 Find Smallest Letter Greater Than Target Easy To Do To Do To Do 745 Prefix and Suffix Search Hard To Do To Do To Do 746 Min Cost Climbing Stairs Easy To Do To Do To Do 747 Largest Number At Least Twice of Others Easy To Do To Do To Do 748 Shortest Completing Word Medium To Do To Do To Do 749 Contain Virus Hard To Do To Do To Do 750 Number Of Corner Rectangles :lock: Medium To Do To Do To Do 751 IP to CIDR :lock: Easy To Do To Do To Do 752 Open the Lock Medium To Do To Do To Do 753 Cracking the Safe Hard To Do To Do To Do 754 Reach a Number Medium To Do To Do To Do 755 Pour Water :lock: Medium To Do To Do To Do 756 Pyramid Transition Matrix Medium To Do To Do To Do 757 Set Intersection Size At Least Two Hard To Do To Do To Do 758 Bold Words in String :lock: Easy To Do To Do To Do 759 Employee Free Time :lock: Hard To Do To Do To Do 760 Find Anagram Mappings :lock: Easy To Do To Do To Do 761 Special Binary String Hard To Do To Do To Do 762 Prime Number of Set Bits in Binary Representation Easy To Do To Do To Do 763 Partition Labels Medium To Do To Do To Do 764 Largest Plus Sign Medium To Do To Do To Do 765 Couples Holding Hands Hard To Do To Do To Do 766 Toeplitz Matrix Easy To Do To Do To Do 767 Reorganize String Medium To Do To Do To Do 768 Max Chunks To Make Sorted II Hard To Do To Do To Do 769 Max Chunks To Make Sorted Medium To Do To Do To Do 770 Basic Calculator IV Hard To Do To Do To Do 771 Jewels and Stones Easy To Do To Do To Do 772 Basic Calculator III :lock: Hard To Do To Do To Do 773 Sliding Puzzle Hard To Do To Do To Do 774 Minimize Max Distance to Gas Station :lock: Hard To Do To Do To Do 775 Global and Local Inversions Medium To Do To Do To Do 776 Split BST :lock: Medium To Do To Do To Do 777 Swap Adjacent in LR String Medium To Do To Do To Do 778 Swim in Rising Water Hard To Do To Do To Do 779 K-th Symbol in Grammar Medium To Do To Do To Do 780 Reaching Points Hard To Do To Do To Do 781 Rabbits in Forest Medium To Do To Do To Do 782 Transform to Chessboard Hard To Do To Do To Do 783 Minimum Distance Between BST Nodes Easy To Do To Do To Do 784 Letter Case Permutation Easy To Do To Do To Do 785 Is Graph Bipartite? Medium To Do To Do To Do 786 K-th Smallest Prime Fraction Hard To Do To Do To Do 787 Cheapest Flights Within K Stops Medium To Do To Do To Do 788 Rotated Digits Easy To Do To Do To Do 789 Escape The Ghosts Medium To Do To Do To Do 790 Domino and Tromino Tiling Medium To Do To Do To Do 791 Custom Sort String Medium To Do To Do To Do 792 Number of Matching Subsequences Medium To Do To Do To Do 793 Preimage Size of Factorial Zeroes Function Hard To Do To Do To Do 794 Valid Tic-Tac-Toe State Medium To Do To Do To Do 795 Number of Subarrays with Bounded Maximum Medium To Do To Do To Do 796 Rotate String Easy To Do To Do To Do 797 All Paths From Source to Target Medium To Do To Do To Do 798 Smallest Rotation with Highest Score Hard To Do To Do To Do 799 Champagne Tower Medium To Do To Do To Do 800 Similar RGB Color :lock: Easy To Do To Do To Do 801 Minimum Swaps To Make Sequences Increasing Medium To Do To Do To Do 802 Find Eventual Safe States Medium To Do To Do To Do 803 Bricks Falling When Hit Hard To Do To Do To Do]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习搜索备忘]]></title>
    <url>%2F2018%2F03%2F16%2FC-%E5%AD%A6%E4%B9%A0%E6%90%9C%E7%B4%A2%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[lambda使用Lambda表达式C++ Lambda表达式基本用法 语法： [ captures ] (可选)(C++20) ( params ) specifiers(可选) exception attr -&gt; ret requires(可选)(C++20) { body }[ captures ] ( params ) -&gt; ret { body }[ captures ] ( params ) { body }[ captures ] { body } std::make_shared的用处std::make_shared有啥用 程序使用动态内存的原因： 程序不知道自己需要多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 shared_ptr的用法: 可以指向特定类型的对象，用于自动释放所指的对象make_shared的用法：在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，与智能指针相同，定义在memory中。 12345shared_ptr&lt;CDlgPointCloud&gt; PointCloudDlgPointer;//指向类型为CDlgPointCloud的对象PointCloudDlgPointer;make_shared&lt;int&gt; p3 = make_shared&lt;int&gt;(42)；// 一般使用auto来保存auto p1 =make_shared&lt;int&gt;(42); 关于std::move和std::forward理解std::move和std::forward std::move和std::forward只不过就是执行cast的两个函数（实际上是函数模板）。std::move无条件地把它的参数转换成一个右值，而std::forward只在特定条件满足的情况下执行这个转换。 右值引用和转移语义右值引用与转移语义 右值引用是用来支持转移语义的。转移语义可以将资源(堆，系统对象等)从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高C++应用程序的性能。临时对象的维护(创建和销毁)对性能有严重影响。转移语义和拷贝语义是相对的，可类比文件的剪切和拷贝。编译器只对右值引用才能调用转移构造函数和赋值函数，而所有命名对象都只能是左值引用，若已知一个命名对象不再被引用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用：标准库提供了函数std::move，该函数以非常简单的方式将左值引用转换为右值引用。 C++常见预定义宏 FILE：文件名 LINE：行数 FUNCTION：函数名称 DATE, TIME：最后一次编译的时间和日期(字符串形式) TIMESTAMP：与TIME格式相同，用于得到本文件最后一次被修改的时间 VERSION：用于得到编译器的版本 I/O：std::ios_base::openmode std::ios_base::in：打开文件进行读操作，即读取文件中的数据 std::ios_base::out：打开文件进行写操作，即写入数据到文件 std::ios_base::in | std::ios_base::out: 打开文件进行读写操作 std::ios_base::app: 每次进行写入操作的时候都会重新定位到文件的末尾 std::ios_base::ate: 打开文件之后立即定位到文件末尾 std::ios_base::trunc: 打开文件，若文件已存在那么，清空文件内容 std::ios_base::binary: 以二进制的方式对打开的文件进行读写 C++文件读写C++文件读写详解（ofstream,ifstream,fstream）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译boost库(VS2015)]]></title>
    <url>%2F2018%2F03%2F16%2F%E7%BC%96%E8%AF%91boost%E5%BA%93-VS2015%2F</url>
    <content type="text"><![CDATA[下载并解压Boost下载地址 编译32位的boost库 编译：msvc版本14.0对应的是vs2015，–stagedir是指定编译后存放的目录。1bjam stage --toolset=msvc-14.0 --without-graph --without-graph_parallel --stagedir=&quot;C:\Boost\boost_1_66_0\bin\vc14&quot; link=static runtime-link=shared runtime-link=static threading=multi debug release 编译64位的boost库1bjam stage --toolset=msvc-14.0 architecture=x86 address-model=64 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14-x64&quot; link=static runtime-link=shared runtime-link=static threading=multi debug release 项目中使用VS项目中添加包含目录和库目录即可]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让子弹飞一会儿]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF%2F</url>
    <content type="text"><![CDATA[你说是钱对我重要，还是你对我重要你和钱对我都不重要，没有你，对我很重要 &emsp;&emsp;虽然这只是我看的姜文的第二部电影，但是在我心中已经可以把他和王小波一样捧到天上去了。前面一部看的是《鬼子来了》，尽管很多人说国民的劣根性，但是我还是为我民族的善良淳朴落泪。 &emsp;&emsp;因为涉及一些政治因素，《鬼子来了》被禁；《太阳照常升起》又因为一些晦涩难懂的隐喻而票房不佳。影评人或者观众或多或少总会有些怀疑姜文的导演能力，这些不认同的声音在他的心里挥之不去。所以这部片子他做出了一些改变，在我看来，一方面既能表达他心中想要表现的观点和情感，另一方便也是为了破除格局获得认同，按其电影里的话来说就是“站着也把钱赚了”(张和冯的电影大多向资本妥协)。从最后的票房结果和影片后续的评论看来，他也确实做到了。 &emsp;&emsp;关于人物关于情节不想多说，人各有见，豆瓣知乎也是有一大堆讨论的。想说的主要是自己对于这部片子和对于姜文的感受。 &emsp;&emsp;在影片中很多地方都能看到姜文的英雄主义情怀，比如松坡将军及小凤仙。不清楚姜文为何对民国时代情有独钟，或许是因为这个动荡的历史时期能有更多的材料能更好的抒发情绪吧。对于角色的名字也是颇为讲究，张牧之(张麻子)、武智冲、马邦德这几个带着或是隐喻或是恶趣味的名字也能让人为之一笑。 &emsp;&emsp;说下印象最深刻的几场戏： 小六子为了自证清白，不想说他中二，只是看到他最后死去的时候，心好像被什么抓住了似得，除了对这个有血性的少年的心疼之外，剩下的也只有对于一哄而散的看客和强权者及畏于强权者的愤怒。 三个影帝同台飙戏，据说是拍了好几十次才完成的，也难怪如此耐看，不管是镜头的转换还是台词对于人物的勾勒对于情节的推动都无可挑剔。有人说是因为姜文对葛优说剧组里有发哥，对发哥说剧组里有葛优才把这两人凑到了一起，且不论真假，能看到这三位出现在同一个大荧幕上就够开心了。 叹号之后的问号，两个简简单单的符号很容易的就表达了其对于革命的必要性以及革命之后的路要怎么走(抑或是对于革命后)的困惑。 “上海就是浦东，浦东就是上海”。 &emsp;&emsp;借用豆瓣上一个影评中的两句话作为结尾吧： 在其最纯粹的意义上，只要贫穷和等级制依然存在，革命就永无止息。然而对于大多数人而言，革命之后，应当是世俗生活的开始，而不是继续革命，更不是永远革命。 于是，一切血与火最终都淹没在湖光山色掩映中的那首《送别》之中，火车开向七十年后改革开放的浦东，尾随的骑士沿着铁轨独行成一个孤绝的背影。这一切，像一个开始，又像一个结尾，更像是一个轮回。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>让子弹飞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python作用域和命名空间示例]]></title>
    <url>%2F2018%2F01%2F15%2FPython%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以下示例演示了如何引用不同作用域和命名空间，以及global和nonlocal如何影响变量绑定：12345678910111213141516171819def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) &emsp;&emsp;输出为：1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 注意：local赋值语句无法改变scope_test的spam绑定。nonlocal赋值语句改变了scope_test的spam绑定，并且global赋值语句从模块级改变了spam绑定。(global赋值语句之前对spam是没有预先绑定的)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码风格]]></title>
    <url>%2F2018%2F01%2F10%2Fpython%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于python，PEP8引入了大多数项目遵循的风格指导。给出了一个高度可读，视觉友好的编码风格。下面是一些关键要点： 使用4空格缩进，而非TAB在小缩进(可以嵌套更深)和大缩进(更易读)之间，4空格是一个较好的折中。TAB引发了一些混乱，最好弃用。 折行以确保其不会超过79字符 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后边，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 同一函数和类命名 推荐类名用驼峰命名函数和方法名用小写_和_下划线 。总是用self作为方法的第一个参数 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的ASCII总是工作的最好 同样，也不要使用非ASCII字符的标识符，除非是不同语种的会阅读或者维护代码]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win必备工具]]></title>
    <url>%2F2018%2F01%2F10%2Fwin%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.Sublime Text&emsp;&emsp;下载地址：Sublime Text&emsp;&emsp;参考博客 最爱的一款文本编辑器，可安装多种插件 2.Cmder&emsp;&emsp;下载地址：Cmder&emsp;&emsp;参考博客 比windows原生cmd好出了天际，支持PowerShell，完全版本自带git。 3.Launchy&emsp;&emsp;下载地址：Launchy 免费开源快速启动软件 安装简易，按alt+space启动 多种皮肤可供选用 提供了一些插件扩展 还可以自定义目录及文件 4.MacType&emsp;&emsp;下载地址：Mactype 改善Windows字体渲染 热替换系统默认字体 &emsp;&emsp;MacType自带了多种配置文件，根据需要选择即可。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++(第三版)读书笔记]]></title>
    <url>%2F2018%2F01%2F10%2FEffective%20C%2B%2B(%E7%AC%AC%E4%B8%89%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 让自己习惯C++(Accustoming Yourself to C++)条款01：视C++为一个语言联邦(View C++ as a federation of languages) C。C++以C为基础。区块(blocks)、语句(statements)、预处理器(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)。 Object-Oriented C++。classes(包括构造函数和析构函数)，封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual函数(动态绑定)…… Template C++。C++的泛型编程(generic programing)部分。 STL。STL是个template程序库。它对容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象的规约有极佳的紧密配合与协调。 &emsp;&emsp;记住这四个次语言，每个次语言都有自己的规约(视情况而定)。 条款02. 尽量以const，enum，inline替换#define(Prefer consts, enums, and inlines to #defines) 对于单纯常量，最好以const对象或enums替换#define。 对于形似函数的宏(macros)，最好改用inline函数替换#defines。 条款03. 尽可能使用const(Use const whenever possible)&emsp;&emsp;const允许你指定一个语义约束(指定一个“不该被改动”的对象)，而编译器会强制实施这项约束。将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。1234567// 如果const出现在星号左边，表示被指物是常量；// 如果const出现在星号右边，表示指针本身是常量；char greeting[] = "Hello";char* p = greeting; // non-const pointer, non-const dataconst char* p = greeting; // non-const pointer, const datachar* const p = greeting; // const pointer, non-const dataconst char* const p = greeting; // const pointer, const data &emsp;&emsp;如果希望STL迭代器所指的东西不可被改动(即希望STL模拟一个const T*指针)，需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin(); // iter的作用像个T* const*iter = 10; // 没问题，改变iter所指物++iter; // 错误！iter是constconst std::vector&lt;int&gt;::const_iterator citer = vec.begin(); // citer的作用像个const T**citer = 10; // 错误！*citer是const++citer; // 没问题，改变cIter const成员函数&emsp;&emsp;将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。重要原因有两点: 使得class接口比较容易被理解。因为，得知哪个函数可以改动对象内容而哪个不行，是很重要的。 使得“操作const对象”成为可能。 条款04. 确定对象被使用前已先被初始化(Make sure that objects are initialized before they are used) 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 2.构造/析构/赋值运算(Constructors, Destructors, and Assignment Operators)条款05. 了解C++默默编写并调用哪些函数(Know what functions C++ silently writes and calls) 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符、以及析构函数。 &emsp;&emsp;如果你写下：1class Empty &#123; &#125;; &emsp;&emsp;实际上是：12345678class Empty &#123;public: Empty() &#123;...&#125; // default构造函数 Empty(const Empty&amp; rhs) &#123;...&#125; // copy构造函数 ~Empty() &#123;...&#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125;// copy assignment操作符&#125;; &emsp;&emsp;如果本身声明了构造函数，编译器就不再为它创建default构造函数。 条款06. 若不想使用编译器自动生成的函数，就该明确拒绝(Explicitly disallow the use of compiler-generated functions you do not want.) 为驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为private并且不予实现。使用Uncopyable这样的base class也是一种做法。 1234567891011121314151617181920212223// Solution 1：class HomeForSale &#123;public: ...private: ... HomeForSale(const HomeForSale&amp;); // 只有声明 HomeForSale&amp; operator=(const HomeForSale&amp;); &#125;;// Solution 2:class Uncopyable &#123; // 允许derived对象构造和析构protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable&amp;)； // 但阻止copying Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;// 为求阻止HomeForSale对象被拷贝，唯一需要做的是继承Uncopyable:class HomeForSale: private Uncopyable &#123; // class 不在声明 ... // copy构造函数或&#125;; // copy assign 操作符 条款07. 为多态基类声明virtual析构函数(Declare destructors virtual in polymorphic base classes.)&emsp;&emsp;(多态性质情况下)为防止出现“局部销毁”对象，造成资源泄露等结果，需要给base class一个virtual析构函数。伺候删除derived class对象就会销毁整个对象，包括derived class成分：123456789class TimeKeeper &#123;public: TimeKeeper(); virtual ~TimeKeeper(); ...&#125;;TimeKeeper* ptk = getTimeKeeper();...delete ptk; // 现在，行为正确 如果class不含virtual函数，通常表示它并不意图被用做一个base class。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 条款08. 别让异常逃离析构函数(Prevent exceptions from leaving destructors) 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行该操作。 条款09. 绝不在构造和析构过程中调用virtual函数(Never call virtual functions during construction or destruction.) 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。 条款10. 令operator= 返回一个reference to *this(Have assigment operators return a reference to *this.)123456789class Widget &#123;public: Widget&amp; operator+=(const Widget&amp; rhs) &#123; ... return* this; &#125; ...&#125;; &emsp;&emsp;注意，这只是个协议，并无强制性。 条款11. 在operator= 中处理“自我赋值”(Handle assignment to self in operator=.) 确保当对象自我赋值时operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 123456789101112131415161718192021222324252627282930class Bitmap &#123;...&#125;;// 1.比较(证同测试)Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if (this == &amp;rhs) return *this; // 证同测试 // 如果是自我赋值，就不做任何事 delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 2.语句顺序Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; // 记住原先的pb pb = new Bitmap(*rhs.pb); // 令pb指向*pb的一个复件(副本) delete pOrig; // 删除原先的pb return *this;&#125;// 3.copy-and-swapclass Widget &#123; ... void swap(Widget&amp; rhs); //交换*this和rhs的数据; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); // 将*this数据和上述复件的数据交换 return *this;&#125; 条款12. 复制对象时勿忘其每一个成分(Copy all parts of an object.)&emsp;&emsp;设计良好之面向对象系统(OO-system)会将对象的内部封装起来，只留两个函数负责对象拷贝(复制)，就是copy构造函数和copy assignment操作符(即为copying函数)。&emsp;&emsp;任何时候只要你承担起“为derived class撰写copying函数”的重责大任，必须很小心地也复制器base class成分。那些成分往往是private，所以无法直接访问它们，你应该让derived class的copying函数调用相应的base class函数。 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。 不要尝试某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中(如init函数)，并由两个copying函数共同调用。 3.资源管理(Resource Management) 内存只是必须管理的众多资源之一，其他常见的资源还包括文件描述器(file descriptors)、互斥锁(mutex locks)、图形界面中的字型和笔刷、数据库连接、以及网络sockets。 条款13. 以对象管理资源(Use objects to manage resources.)123456void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment( )); // 调用factory函数 ... // 一如既往地使用pInv&#125; // 经由auto_ptr的析构甘薯自动删除pInv &emsp;&emsp;这个简单例子示范了“以对象管理资源”的两个关键想法： 获得资源后立刻放进管理对象内。以上代码中createInvestment返回的资源被当作其管理者auto_ptr的初值。实际上“以对象管理资源”的观念常备称为“资源取得时机便是初始化时机”(Resource Acquisition Is Initialization;RAII)。 管理对象运用析构函数确保资源被释放。 &emsp;&emsp;注意auto_ptrs有一个性质：若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权！123std::auto_ptr&lt;Investment&gt; pInv1(createInvestment( )); // pInv1指向createInvestment返回物std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // 现在pInv2指向对象，pInv1被设为nullpInv1 = pInv2; // pInv2被设为null &emsp;&emsp;使用tr1::shared_ptrs比auto_ptrs的复制正常一些。 为防止资源泄露，清使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。 两个常备使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它(被复制物)指向null。 条款14. 在资源管理类中小心copying行为(Think carefully behavior in resource-managing classes.)&emsp;&emsp;RAII守则“资源在构造期间获得，在析构期间释放”。 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法(reference counting)。不过其他行为也都可能被实现。 条款15. 在资源管理类中提供对原始资源的访问(Provide access to raw resources in resource-managing classes.) APIs往往要求访问原始资源(raw resources)，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显式转换或者隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。 条款16. 成对使用new和delete时要采取相同形式(Use the same form in corresponding uses of new and delete) 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 条款17. 以独立语句将newed对象置入智能指针(Store newed objects in smart pointers in standalone statements.)12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // 在单独语句内以只能指针存储newed所得对象processWidget(pw, priority()); // 这个调用动作决不至于造成泄露 以独立语句将newed对象存储于(置入)智能指针中。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 4. 设计与声明(Designs and Declarations) 让接口容易被正确使用，不容易被误用(正确性、高效性、封装性、维护性、延展性、以及协议的一致性)。 条款18. 让接口容易被正确使用，不易被误用(Make interfaces easy to use correctly and hard to use incorrectly.) 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的方法包括建立新类型、限制类型上的操作、束缚对象值、以及消除客户的资源管理责任。 tr1::shared_ptr支持定制型删除器(custom deleter)。这可防范DLL问题，可被用来自动解除互斥锁等等。 条款19. 设计class犹如设计type(Treat class design as type design) 新type的对象应该如何被创建和销毁？ 对象的初始化和对象的赋值该有什么样的差别？ 新type的对象如果被passed by value，意味着什么？ 什么是新type的“合法值”？ 你的新type需要配合某个继承图系(inheritance graph)吗？ 你的新type需要什么样的转换？ 什么样的操作符和函数对此新type而言是合理的？ 什么样的标准函数应该驳回？ 谁该取用新type的成员？ 什么是新type的“未声明接口”(undeclared interface)？ 你的新type有多么一般化？ 你真的需要一个新type吗？ 条款20. 宁以pass-by-reference-to-const替换pass-by-value&emsp;&emsp;缺省情况下C++以by value方式传递对象至函数。 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题(slicing problem)。 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。 条款21. 必须返回对象时，别妄想返回其reference(Don’t try to return a reference when you must return an object.)&emsp;&emsp;一个“必须返回新对象”的函数的正确写法是让其返回一个新对象。1234inline const Rational operator * (const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.n * rhs.n, lhs.d * rhs.d);&#125; 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。 条款22. 将成员变量声明为private(Declare data members private.) 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。 protected并不比public更具封装性。 条款23. 宁以non-member、non-friend替换member函数 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性(packaging flexibility)和机能扩充性。 条款24. 若所有参数皆需类型转换，请为此采用non-member函数(Declare non-member functions when type conversions should apply to all parameters.) 如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换，那么这个函数必须是non-member。 条款25. 考虑写出一个不抛出异常的swap函数(Consider support for a non-throwing swap.) 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。 如果你提供一个member swap，特该提供一个non-member swap用来调用前者。对于classes(而非templates)，也请特化std::swap。 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。 为“用户定义类型”进行std templates全特化是最好的，但千万不要尝试在std内加入某些对std而言全新的东西。 5. 实现(Implementations)&emsp;&emsp;太快定义变量可能造成效率上的拖延；过渡使用转型(casts)可能导致代码变慢又难维护，又找来微妙难解的错误；返回对象“内部数据之号码牌(handles)”可能会破坏封装并留给客户虚吊号码牌(danling handles)；未考虑异常带来的冲击则可能导致资源泄露和数据败坏；过渡热心地inlining可能引起代码膨胀；过渡耦合(coupling)则可能导致让人不满意的冗长建置时间(build times)。 条款26. 尽可能延后变量定义式的出现时间(Postpone variable definitions as long as possible.)&emsp;&emsp;不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初始实参为止。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的default构造行为。 条款27. 尽量少做转型动作(Minimize casting.)&emsp;&emsp;C++提供了四种新式转型(new-style/C++-style casts)123456789// 旧式 old-style casts(T)expression //将expression转型为TT(expression) //~// new-styleconst_cast&lt;T&gt;( expression )dynamic_cast&lt;T&gt;( expression )reinterpret_cast&lt;T&gt;( expression )static_cast&lt;T&gt;( expression ) &emsp;&emsp;各有不同的目的： const_cast通常被用来将对象的常量性移除(cast away the constness)。也是唯一有此能力的 C++-style转型操作符。 dynamic_cast主要用来执行“安全向下转型”(safe downcasting)，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。 reinterpret_cast意图执行低级转型，实际动作及结果可能取决于编译器，也就是说它不可移植。 static_cast用来强迫隐式转换(implicit conversions)，例如将non-const对象转为const对象等。它也可以用来执行上述多种转换的反向转换，但无法将const转为non-const。 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。 宁可使用C++-style(新式)转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的德州的执掌。 条款28. 避免返回handles指向对象内部成分(Avoid returning “handles” to object internals.) 成员变量的封装性最多只能等于“返回其reference”的函数的访问级别。 如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。&emsp;&emsp;如果返回的是指针或迭代器，相同的情况还是发生，原因也相同。References、指针和迭代器都是所谓的handles 避免返回handles(包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”(dangling handles)的可能性降至最低。 条款29. 为“异常安全”而努力是值得的(Strive for exception-safe code.)&emsp;&emsp;当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 &emsp;&emsp;异常安全函数(Exception-safe functions)提供以下三个保证之一： 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，任何对象都处于一种内部前后一致的状态(例如所有的class约束条件都继续获得满足)。 强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。 不抛掷(nothrow)保证：承诺绝不抛出异常，因为它们总能够完成它们原先承诺的功能。作用于内置类型(例如ints，指针等等)身上的所有操作都提供nothrow保证。 异常安全函数(Exception-safe functions)即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证中的最弱者”。 条款30. 透彻了解inlining的里里外外(Understand the ins and outs of inlining.)&emsp;&emsp;80-20经验法则：平均而言一个程序往往将80%的执行时间花费在20%的代码上。 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability)更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。 条款31. 将文件间的编译依存关系降至最低(Minimize compilation dependencies between files.)&emsp;&emsp;编译依存性最小化的本质：显示中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式(而非定义式)相依： 如果使用object references 或 object pointers可以完成任务，就不要使用objects。 如果能够，尽量以class声明式替换class定义式。 为声明式和定义式提供不同的头文件。 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。 程序库头文件应该以“完全且仅有声明式”(full and declaration-only forms)的形式存在。这种做法不论是否涉及templates都适用。 6 继承与面向对象设计(Inheritance and Object-Oriented Design.)条款32. 确定你的public继承塑模出is-a关系(Make sure public inheritance models “is-a.”) “public继承”以为is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。 条款33. 避免遮掩继承而来的名称(Avoid hiding inherited names.) derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwarding functions)。 条款34. 区分接口继承和实现继承(Differentiate between inheritance of interface and inheritance of implementation.)&emsp;&emsp;pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。而impure virtual函数会提供一份实现代码，derived classes可能覆写(override)它。一个non-virtual成员函数所表现的不变性(invariant)凌驾其特异性(specialization)，因为它表示不论derived class变得多么特异化，它的行为都不可以改变，也绝不该在derived class中被重新定义。 成员函数的接口总是会被继承。 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。 声明简朴的(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现。 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。 条款35. 考虑virtual函数以外的其他选择(Consider alternatives to virtual functions.) 使用non-virtual interface(NVI)手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected)的virtual函数。 将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。 以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物搭配一个兼容于需求的签名式。这也是Strategy设计模式的眸子形式。 将基础体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。 条款36. 绝不重新定义继承而来的non-virtual函数(Never redefine an inherited non-virtual function.)&emsp;&emsp;non-virtual函数实静态绑定的，如pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生之class”的对象；而virtual函数却是可以动态绑定的。 条款37. 绝不重新定义继承而来的缺省参数值(Never redefine a function’s inherited default parameter value.)&emsp;&emsp;virtual函数系动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值。 静态绑定：又名前期绑定(early binding) 静态类型(static type)：在程序中被声明时所采用的类型。 动态绑定：又名后期绑定(late binding) 动态类型(dynamic type):指的是“目前所指对象的类型”，也就是说，没动态类型可以表现出一个对象将会有什么行为。。 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数————你唯一应该覆写的东西————却是动态绑定。 条款38. 通过复合塑模出has-a或“根据某物实现出”(Model “has-a” or “is-implemented-in-terms-of” through composition.) 复合(composition)的意义和public继承完全不同。 在应用域(application domain)，复合意味has-a(有一个)。在实现域(implementation domain)，复合意味is-implemented-in-terms-of(根据某物实现出)。 条款39. 明智而审慎地使用private继承(Use private inheritance judiciously.) 如果classes之间的继承关系是private，编译器不会自动将一个derived class对象(例如Student)转换为一个base class对象(例如Person)。这和public继承不同。 由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性。 &emsp;&emsp;private继承意味着只有实现部分被继承，接口部分略去。 private继承意味is-implemented-in-terms of(根据某物实现出)。它通常比复合(composition)的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合(composition)不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。 条款40. 明智而审慎地使用多重继承(Use multiple inheritance judiciously.) 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。 7. 模板与泛型编程(Templates and Generic Programming.)(粗略阅读)条款41. 了解隐式接口和编译期多态(Understand implicit interfaces and compile-time polymorphism.) classes 和 templates都支持接口(interfaces)和多态(polymorphism)。 对classes而言接口是显式的(explicit)，以函数签名为中心。多态则是通过vvirtual函数发生于运行期。 对templa参数而言，接口是隐式的(implicit)，奠基于有效表达式。多态则是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。 条款42. 了解typename的双重意义(Understand the two meanings of typename.) 声明template参数时，前缀关键字class和typename可互换。 请使用关键字typename标识嵌套从属类型名称；但不得在base class lists(基类列)或member initialization list(成员初值列)内以它作为base class修饰符。 条款43. 学习处理模板化基类内的名称(Know how to access names in templatized base classes.) 可在derived class templates内通过“this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。 条款44. 将与参数无关的代码抽离templates(Factor parameter-independent code out of templates.) Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀，往往可降低，做法是让带有完全相同的二进制表述(binary representations)的具现类型(instantiation types)共享实现码。 条款45. 运用成员函数模板接受所有兼容类型(Use member function templates accept “all compatible types.”) 请使用member function templates(成员函数模板)生成“可接受所有兼容类型”的函数。 如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。 条款46. 需要声明类型转换时轻微模板定义非成员函数(Define non-member functions inside templates when type conversions are desired.) 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。 条款47. 请使用traits classes表现类型信息(Use traits classes for information about types.) Traits classes使得“类型相关信息”在编译器可用。它们以templates和“templates特化”完成实现。 整合重载技术(overloading)后，traits classes有可能在编译器对类型执行if…else测试。 条款48. 认识template元编程(Be aware of template metaprogramming.) Template metaprogramming(TMP，模板元编程)可将工作由运行期移往编译器，因而得以实现早期错误侦测和更高的执行效率。 TMP可被用来生成“基于政策选择组合”(based on combinations of policy choices)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 8. 定制new和delete(CUstomizing new and delete)(粗略阅读)条款49. 了解new-handler的行为(Understand the behavior of the new-handler.) set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。 条款50. 了解new和delete的合理替换时机(Understand when it makes sense to replace new and delete.) 有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。 条款51. 编写new和delete时需固守常规(Adhere to convention when writing new and delete.) operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 条款52.写了placement new也要写placement delete(Write placement delete if you write placement new.) 当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明placement new 和placement delete，请确定不要无意识(非故意)地遮掩了它们的正常版本。 9. 杂项讨论(Miscellany)条款53. 不要轻忽编译器的警告(Pay attention to compiler warnings.) 严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。 不要过度依赖编译器的报警能力，因为不同的编译器对待事物的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 条款54. 让自己熟悉包括TR1在内的标准程序库(Familiarize yourself with the standard library, including TR1.)&emsp;&emsp;C++98列入的C++标准程序库的主要成分： STL(Standard Template Library，标准模板库)，覆盖容器(containers如vector,string,map)、迭代器(iterator)、算法(algorithms如find，sort，transform)、函数对象(function objects如less，greater)、各种容器适配器(container adapters如stack，priority_queue)和函数对象适配器(function object adapters如mem_fun，not1)。Iostream，覆盖用户自定缓冲功能、国际化I/O，以及预先定义好的对象cin，cout，cerr和clog。国际化支持，包括多区域(multiple active locales)能力。像wchar_t(16bits/char)和wstring(wchar_ts组成的strings)等类型都对促进Unicode有所帮助，数值处理，包括复数模板(complex)和纯数值数组(valarray)。异常阶层体系(exception hierarchy)，包括base class exception及其derived classes logic_cerr和runtime_error，以及更深继承的各个classes。C89标准程序库。1989C标准程序库内的每个东西也都被覆盖于C++内。 &emsp;&emsp;TR1详细叙述了14个新组件(components，也就是程序库机能单位)，统统放在std命名空间内，更正确地说是在其嵌套命名空间tr1内。 智能指针(smart pointers) tr1::shared_ptr和tr1::weak_ptr。 tr1::function，此物得以表示任何callable entity(可调用物，也就是任何函数或函数对象)，只要其签名符合目标。 tr1::bind，它能够做STL绑定器(binders)bind1st和bind2nd所做的每一件事，而又更多。 Hash tables，用来实现sets，multisets，maps和multi-maps。 正则表达式(Regular expressions)，包括正则表达式为基础的字符串查找和替换，或是从某个匹配字符串到另一个匹配字符串的逐一迭代(iterator)等等。 Tuples(变量组)，这是标准程序库中的pair template的新一代制品。pair只能持有两个对象，tr1::tuple可持有任意个数的对象。 tr1::aray，本质上是个“STL化”数组，即一个支持成员函数如begin和end的数组。不过tr1::array的大小固定，并不适用动态内存。 tr1::mem_fn，这是个语气构造上与成员函数指针(member function pointers)一致的东西。 tr1::reference_wrapper，一个“让references的行为更像对象”的设施。它可以造成对象容器“犹如持有references”。 随机数(random number)生成工具，它大大超越了rand，那是C++继承自C标准程序库的一个函数。 数学特殊函数，包括Laguerre多项式、Bessel函数、完全椭圆积分(complete elliptic integrals)，以及更多数学函数。 C99兼容扩充。这是一大堆函数和模板，用来将许多新的C99程序库特性带进C++。 Type traits，一组traits classes，用于提供类型(types)的编译期信息。 tr1::result_of，这是个template，用来推到函数调用的返回类型。 C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。 TR1添加了智能指针(如tr1::shared_ptr)、一般化函数指针(tr1::function)、hash-based容器、正则表达式(regular expressions)以及另外是个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是Boost。 条款55：让自己熟悉Boost(Familiarize yourself with Boost.)&emsp;&emsp;Boost程序库对付的主题非常繁多，区分数十个类目，包括(程序库抽样)： 字符串与文本处理，覆盖具备类型安全(safe-type)的printf-like格式化动作、正则表达式，以及语汇单元切割(tokenizing)和解析(parsing)。 容器，覆盖“接口与STL相似且大小固定”的数组、大小可变的bitsets以及多位数组。 函数对象和高级编程，覆盖若干倍用来作为TR1机能基础的程序库。 泛型编程(Generic programming)，覆盖一大组traits classes。 模板元编程(Template metaprogramming, TMP)，覆盖一个针对编译器assertions而写的程序库，以及Boost MPL程序库。 数学与数值(Math and numerics)，包括有理数、八元数和四元数(octonions and quaternions)、常见的公约数(divisor)和少见的多重运算、随机数。 正确性与测试(Correctness and testing)，覆盖用来将隐式模板接口形式化的程序库，以及针对“测试优先”编程形态而设计的措施。 数据结构，覆盖类型安全和unions以及tuple程序库。 语言间的支持(Inter-language support)，包括允许C++和Python之间的无缝互操作性(seamless interoperability)。 内存，覆盖Pool程序库，用来做出高效率而区块大小固定的分配器，以及多变化的智能指针，包括TR1智能指针。 杂项，包括CRC检验、日期和时间的处理、在文件系统上来回移动等等。 Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。 Boost提供许多TR1组件实现品，以及其他许多程序库。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next配置]]></title>
    <url>%2F2018%2F01%2F05%2FHexo-Next%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 添加[关于][标签]等页面 hexo new page about hexo new page tags 2.头像设置&emsp;&emsp;修改站点配置文件，修改avatar,值设置成头像的链接或者地址1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 3. 圆形头像（添加旋转）&emsp;&emsp;Next主题默认不支持，修改source/css/_common/components/sidebar/sidebar-author.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 4.删除底部HEXO主题和主题&emsp;&emsp;修改\themes\next\layout_partials\footer.swig文件，删除:12345678910&lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt; 5.网站底部添加访问量&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件，在copyright前加上：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;然后再合适的位置添加显示统计的代码:12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &emsp;&emsp;这里有两种计算方式的统计代码: pv方式，单个用户连续点击n篇文章，记录n次访问量 uv方式，单个用户连续点击n篇文章，只记录1次访客量 6. 网站底部字数统计&emsp;&emsp;切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save &emsp;&emsp;然后在/themes/next/layout/_partials/footer.swig恰当位置添加： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 7.设置网站的图标Favicon&emsp;&emsp;在EasyIcon中找到适当的比例的ico图标，或者从别的网站下载或制作，并将名称修改为favicon.ico，然后将图标放在/themes/next/source/images，并修改主题配置文件：12345678favicon: small: /images/favicon.ico #favicon-16x16-next.png medium: /images/favicon.ico #favicon-32x32-next.png apple_touch_icon: /images/favicon.ico #apple-touch-icon-next.png safari_pinned_tab: /images/favicon.ico 8.实现统计功能&emsp;&emsp;在根目录下安装hexo-wordcount，运行1$ npm install hexo-wordcount --save &emsp;&emsp;然后在主题配置文件中，配置如下：1234post_wordcount: item_text: true wordcount: true min2read: true 9.添加顶部加载条&emsp;&emsp;修改主题配置文件，将pace: false改为pace: true即可，里面还内置了很多样式，可直接更换。 10.设置阅读全文 在文章中使用手动进行截断(推荐): 1&lt;!-- more --&gt; 在文章的front-matter中添加description，并提供文章摘录 自动形成摘要，在主题配置文件中添加：123auto_excerpt:enable: truelength: 150 11.文章打赏&emsp;&emsp;在文章开头添加reward: true，并修改主题配置页面：1234# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 12.返回顶部组件增加百分比&emsp;&emsp;在主题配置文件中修改scrollpercent 13.博文置顶&emsp;&emsp;将文件node_modules/hexo-generator-index/lib/generator.js中代码修改为12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; &emsp;&emsp;在文章中添加top值，数值越大，文章越靠前。 14.修改打赏字体不闪动&emsp;&emsp;修改文件123456789101112```/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 15.添加评论功能（liveRe 来必力）&emsp;&emsp;注册来必力，获取liver_uid，编辑主题配置文件，编辑livere_uid即可。 16.添加阅读次数&emsp;&emsp;注册LeanCloud 首先在应用创建一个应用，名字随意 然后在存储-&gt;数据中创建class，取名为Counter 在设置-&gt;应用Key中取得APP ID和APP Key 回到设置，选择安全中心，在Web安全域名中添加博客地址 &emsp;&emsp;修改主题配置文件:1234leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key 17. 修改文章底部带#标签&emsp;&emsp;修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 18. 修改文章内链接文本样式&emsp;&emsp;将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件themes\next\source\css_custom\custom.styl，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 19.搜索功能&emsp;&emsp;安装hexo-generator-searchdb，在站点根目录下执行1$ npm install hexo-generator-searchdb --save &emsp;&emsp;编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 &emsp;&emsp;修改主题配置文件：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 20.创建分类页面 新建一个页面， 1hexo new page categories 编辑新建的页面，增加 1type: categories 屏蔽评论功能， 1comments: false 菜单中添加链接，编辑主题配置文件，解注释 1categories &emsp;&emsp;(tags页面类似) 21.文章多个Tag分割 使用tags:[tag1, tag2]这样的形式即可。]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假面饭店]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%81%87%E9%9D%A2%E9%A5%AD%E5%BA%97%2F</url>
    <content type="text"><![CDATA[饭店人员一边想象着客人的本来面目，一边还必须要尊重他们的假面具，决不能试图摘下来。因为某种程度上，客人是为了享受面具舞会才来的饭店。 &emsp;&emsp;这本书和他之前的作品一样，阅读过程十分顺畅，多少有点欲罢不能。故事结构完整，情节设计精巧，但是推理节奏较为拖沓；最终决战到来之前的风雨欲来的紧迫感营造的很优秀，但是最终的杀人动机极为狗血。&emsp;&emsp;作者在主线情节的中间还穿插着一些支线情节，这些段落插曲一方面丰满了人物，另一方面也促进了情节的推动，每一个小故事或多或少的提供了一点线索。经纬度和环形密码还是比较有趣的。&emsp;&emsp;印象最深的还是男女主角对于工作的高度责任心。两个完全不相关的职业以及思考方式，在推理判断过程中的成长，从开始的互不理解到互相欣赏，在推理之余增加了温情。&emsp;&emsp;可能是因为之前看的东野的小说都太过经典和优秀（白夜行，解忧杂货铺等），所以对这本书阅读体验并不如期待。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
</search>
