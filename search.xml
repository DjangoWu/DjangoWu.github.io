<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[让子弹飞一会儿]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF%2F</url>
    <content type="text"><![CDATA[你说是钱对我重要，还是你对我重要你和钱对我都不重要，没有你，对我很重要 &emsp;&emsp;虽然这只是我看的姜文的第二部电影，但是我已经觉得在我心中已经可以把他和王小波意义捧到天上去了。前面一部看的是《鬼子来了》，尽管很多人说国民的劣根性，但是我还是为我民族的善良淳朴落泪。 &emsp;&emsp;因为涉及一些政治因素，《鬼子来了》被禁；《太阳照常升起》又因为一些晦涩难懂的隐喻而票房不佳。影评人或者观众或多或少总会有些怀疑姜文的导演能力，这些不认同的声音在他的心里挥之不去。所以这部片子他做出了一些改变，在我看来，一方面既能表达他心中想要表现的观点和情感，另一方便也是为了破除格局获得认同，按其电影里的话来说就是“站着也把钱赚了”(张和冯的电影大多向资本妥协)。从最后的票房结果和影片后续的评论看来，他也确实做到了。 &emsp;&emsp;关于人物关于情节不想多说，人各有见，豆瓣知乎也是有一大堆讨论的。想说的主要是自己对于这部片子和对于姜文的感受。 &emsp;&emsp;在影片中很多地方都能看到姜文的英雄主义情怀，比如松坡将军及小凤仙。不清楚姜文为何对民国时代情有独钟，或许是因为这个动荡的历史时期能有更多的材料能更好的抒发情绪吧。对于角色的名字也是颇为讲究，张牧之(张麻子)、武智冲、马邦德这几个带着或是隐喻或是恶趣味的名字也能让人为之一笑。 &emsp;&emsp;说下印象最深刻的几场戏： 小六子为了自证清白，不想说他中二，只是看到他最后死去的时候，心好像被什么抓住了似得，除了对这个有血性的少年的心疼之外，剩下的也只有对于一哄而散的看客和强权者及畏于强权者的愤怒。 三个影帝同台飙戏，据说是拍了好几十次才完成的，也难怪如此耐看，不管是镜头的转换还是台词对于人物的勾勒对于情节的推动都无可挑剔。有人说是因为姜文对葛优说剧组里有发哥，对发哥说剧组里有葛优才把这两人凑到了一起，且不论真假，能看到这三位出现在同一个大荧幕上就够开心了。 叹号之后的问号，两个简简单单的符号很容易的就表达了其对于革命的必要性以及革命之后的路要怎么走(抑或是对于革命后)的困惑。 “上海就是浦东，浦东就是上海”。 &emsp;&emsp;借用豆瓣上一个影评中的两句话作为结尾吧： 在其最纯粹的意义上，只要贫穷和等级制依然存在，革命就永无止息。然而对于大多数人而言，革命之后，应当是世俗生活的开始，而不是继续革命，更不是永远革命。 于是，一切血与火最终都淹没在湖光山色掩映中的那首《送别》之中，火车开向七十年后改革开放的浦东，尾随的骑士沿着铁轨独行成一个孤绝的背影。这一切，像一个开始，又像一个结尾，更像是一个轮回。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>让子弹飞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python作用域和命名空间示例]]></title>
    <url>%2F2018%2F01%2F15%2FPython%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以下示例演示了如何引用不同作用域和命名空间，以及global和nonlocal如何影响变量绑定：12345678910111213141516171819def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) &emsp;&emsp;输出为：1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 注意：local赋值语句无法改变scope_test的spam绑定。nonlocal赋值语句改变了scope_test的spam绑定，并且global赋值语句从模块级改变了spam绑定。(global赋值语句之前对spam是没有预先绑定的)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码风格]]></title>
    <url>%2F2018%2F01%2F10%2Fpython%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于python，PEP8引入了大多数项目遵循的风格指导。给出了一个高度可读，视觉友好的编码风格。下面是一些关键要点： 使用4空格缩进，而非TAB在小缩进(可以嵌套更深)和大缩进(更易读)之间，4空格是一个较好的折中。TAB引发了一些混乱，最好弃用。 折行以确保其不会超过79字符 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后边，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 同一函数和类命名 推荐类名用驼峰命名函数和方法名用小写_和_下划线 。总是用self作为方法的第一个参数 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的ASCII总是工作的最好 同样，也不要使用非ASCII字符的标识符，除非是不同语种的会阅读或者维护代码]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win必备工具]]></title>
    <url>%2F2018%2F01%2F10%2Fwin%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.Sublime Text&emsp;&emsp;下载地址：Sublime Text&emsp;&emsp;参考博客 最爱的一款文本编辑器，可安装多种插件 2.Cmder&emsp;&emsp;下载地址：Cmder&emsp;&emsp;参考博客 比windows原生cmd好出了天际，支持PowerShell，完全版本自带git。 3.Launchy&emsp;&emsp;下载地址：Launchy 免费开源快速启动软件 安装简易，按alt+space启动 多种皮肤可供选用 提供了一些插件扩展 还可以自定义目录及文件 4.MacType&emsp;&emsp;下载地址：Mactype 改善Windows字体渲染 热替换系统默认字体 &emsp;&emsp;MacType自带了多种配置文件，根据需要选择即可。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++(第三版)读书笔记]]></title>
    <url>%2F2018%2F01%2F10%2FEffective%20C%2B%2B(%E7%AC%AC%E4%B8%89%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 让自己习惯C++(Accustoming Yourself to C++)条款01：视C++为一个语言联邦(View C++ as a federation of languages) C。C++以C为基础。区块(blocks)、语句(statements)、预处理器(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)。 Object-Oriented C++。classes(包括构造函数和析构函数)，封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual函数(动态绑定)…… Template C++。C++的泛型编程(generic programing)部分。 STL。STL是个template程序库。它对容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象的规约有极佳的紧密配合与协调。 &emsp;&emsp;记住这四个次语言，每个次语言都有自己的规约(视情况而定)。 条款02. 尽量以const，enum，inline替换#define(Prefer consts, enums, and inlines to #defines) 对于单纯常量，最好以const对象或enums替换#define。 对于形似函数的宏(macros)，最好改用inline函数替换#defines。 条款03. 尽可能使用const(Use const whenever possible)&emsp;&emsp;const允许你指定一个语义约束(指定一个“不该被改动”的对象)，而编译器会强制实施这项约束。将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。1234567// 如果const出现在星号左边，表示被指物是常量；// 如果const出现在星号右边，表示指针本身是常量；char greeting[] = "Hello";char* p = greeting; // non-const pointer, non-const dataconst char* p = greeting; // non-const pointer, const datachar* const p = greeting; // const pointer, non-const dataconst char* const p = greeting; // const pointer, const data &emsp;&emsp;如果希望STL迭代器所指的东西不可被改动(即希望STL模拟一个const T*指针)，需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin(); // iter的作用像个T* const*iter = 10; // 没问题，改变iter所指物++iter; // 错误！iter是constconst std::vector&lt;int&gt;::const_iterator citer = vec.begin(); // citer的作用像个const T**citer = 10; // 错误！*citer是const++citer; // 没问题，改变cIter const成员函数&emsp;&emsp;将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。重要原因有两点: 使得class接口比较容易被理解。因为，得知哪个函数可以改动对象内容而哪个不行，是很重要的。 使得“操作const对象”成为可能。 条款04. 确定对象被使用前已先被初始化(Make sure that objects are initialized before they are used) 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 2.构造/析构/赋值运算(Constructors, Destructors, and Assignment Operators)条款05. 了解C++默默编写并调用哪些函数(Know what functions C++ silently writes and calls) 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符、以及析构函数。 &emsp;&emsp;如果你写下：1class Empty &#123; &#125;; &emsp;&emsp;实际上是：12345678class Empty &#123;public: Empty() &#123;...&#125; // default构造函数 Empty(const Empty&amp; rhs) &#123;...&#125; // copy构造函数 ~Empty() &#123;...&#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125;// copy assignment操作符&#125;; &emsp;&emsp;如果本身声明了构造函数，编译器就不再为它创建default构造函数。 条款06. 若不想使用编译器自动生成的函数，就该明确拒绝(Explicitly disallow the use of compiler-generated functions you do not want.) 为驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为private并且不予实现。使用Uncopyable这样的base class也是一种做法。 1234567891011121314151617181920212223// Solution 1：class HomeForSale &#123;public: ...private: ... HomeForSale(const HomeForSale&amp;); // 只有声明 HomeForSale&amp; operator=(const HomeForSale&amp;); &#125;;// Solution 2:class Uncopyable &#123; // 允许derived对象构造和析构protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable&amp;)； // 但阻止copying Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;// 为求阻止HomeForSale对象被拷贝，唯一需要做的是继承Uncopyable:class HomeForSale: private Uncopyable &#123; // class 不在声明 ... // copy构造函数或&#125;; // copy assign 操作符 07. 为多态基类声明virtual析构函数(Declare destructors virtual in polymorphic base classes.)&emsp;&emsp;(多态性质情况下)为防止出现“局部销毁”对象，造成资源泄露等结果，需要给base class一个virtual析构函数。伺候删除derived class对象就会销毁整个对象，包括derived class成分：123456789class TimeKeeper &#123;public: TimeKeeper(); virtual ~TimeKeeper(); ...&#125;;TimeKeeper* ptk = getTimeKeeper();...delete ptk; // 现在，行为正确 如果class不含virtual函数，通常表示它并不意图被用做一个base class。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 08. 别让异常逃离析构函数(Prevent exceptions from leaving destructors) 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行哎操作。 09. 绝不在构造和析构过程中调用virtual函数(Never call virtual functions during construction or destruction.) 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。 10. 令operator= 返回一个reference to *this(Have assigment operators return a reference to *this.)123456789class Widget &#123;public: Widget&amp; operator+=(const Widget&amp; rhs) &#123; ... return* this; &#125; ...&#125;; &emsp;&emsp;注意，这只是个协议，并无强制性。 11. 在operator= 中处理“自我赋值”(Handle assignment to self in operator=.) 确保当对象自我赋值时operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 123456789101112131415161718192021222324252627282930class Bitmap &#123;...&#125;;// 1.比较(证同测试)Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if (this == &amp;rhs) return *this; // 证同测试 // 如果是自我赋值，就不做任何事 delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 2.语句顺序Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; // 记住原先的pb pb = new Bitmap(*rhs.pb); // 令pb指向*pb的一个复件(副本) delete pOrig; // 删除原先的pb return *this;&#125;// 3.copy-and-swapclass Widget &#123; ... void swap(Widget&amp; rhs); //交换*this和rhs的数据; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); // 将*this数据和上述复件的数据交换 return *this;&#125; 12. 复制对象时勿忘其每一个成分(Copy all parts of an object.) 未完待续]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next配置]]></title>
    <url>%2F2018%2F01%2F05%2FHexo-Next%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 添加[关于][标签]等页面 hexo new page about hexo new page tags 2.头像设置&emsp;&emsp;修改站点配置文件，修改avatar,值设置成头像的链接或者地址1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 3. 圆形头像（添加旋转）&emsp;&emsp;Next主题默认不支持，修改source/css/_common/components/sidebar/sidebar-author.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 4.删除底部HEXO主题和主题&emsp;&emsp;修改\themes\next\layout_partials\footer.swig文件，删除:12345678910&lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt; 5.网站底部添加访问量&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件，在copyright前加上：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;然后再合适的位置添加显示统计的代码:12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &emsp;&emsp;这里有两种计算方式的统计代码: pv方式，单个用户连续点击n篇文章，记录n次访问量 uv方式，单个用户连续点击n篇文章，只记录1次访客量 6. 网站底部字数统计&emsp;&emsp;切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save &emsp;&emsp;然后在/themes/next/layout/_partials/footer.swig恰当位置添加：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 7.设置网站的图标Favicon&emsp;&emsp;在EasyIcon中找到适当的比例的ico图标，或者从别的网站下载或制作，并将名称修改为favicon.ico，然后将图标放在/themes/next/source/images，并修改主题配置文件：12345678favicon: small: /images/favicon.ico #favicon-16x16-next.png medium: /images/favicon.ico #favicon-32x32-next.png apple_touch_icon: /images/favicon.ico #apple-touch-icon-next.png safari_pinned_tab: /images/favicon.ico 8.实现统计功能&emsp;&emsp;在根目录下安装hexo-wordcount，运行1$ npm install hexo-wordcount --save &emsp;&emsp;然后在主题配置文件中，配置如下：1234post_wordcount: item_text: true wordcount: true min2read: true 9.添加顶部加载条&emsp;&emsp;修改主题配置文件，将pace: false改为pace: true即可，里面还内置了很多样式，可直接更换。 10.设置阅读全文 在文章中使用手动进行截断(推荐): 1&lt;!-- more --&gt; 在文章的front-matter中添加description，并提供文章摘录 自动形成摘要，在主题配置文件中添加：123auto_excerpt:enable: truelength: 150 11.文章打赏&emsp;&emsp;在文章开头添加reward: true，并修改主题配置页面：1234# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 12.返回顶部组件增加百分比&emsp;&emsp;在主题配置文件中修改scrollpercent 13.博文置顶&emsp;&emsp;将文件node_modules/hexo-generator-index/lib/generator.js中代码修改为12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; &emsp;&emsp;在文章中添加top值，数值越大，文章越靠前。 14.修改打赏字体不闪动&emsp;&emsp;修改文件123456789101112```/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 15.添加评论功能（liveRe 来必力）&emsp;&emsp;注册来必力，获取liver_uid，编辑主题配置文件，编辑livere_uid即可。 16.添加阅读次数&emsp;&emsp;注册LeanCloud 首先在应用创建一个应用，名字随意 然后在存储-&gt;数据中创建class，取名为Counter 在设置-&gt;应用Key中取得APP ID和APP Key 回到设置，选择安全中心，在Web安全域名中添加博客地址 &emsp;&emsp;修改主题配置文件:1234leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key 17. 修改文章底部带#标签&emsp;&emsp;修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 18. 修改文章内链接文本样式&emsp;&emsp;将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件themes\next\source\css_custom\custom.styl，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 19.搜索功能&emsp;&emsp;安装hexo-generator-searchdb，在站点根目录下执行1$ npm install hexo-generator-searchdb --save &emsp;&emsp;编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 &emsp;&emsp;修改主题配置文件：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 20.创建分类页面 新建一个页面， 1hexo new page categories 编辑新建的页面，增加 1type: categories 屏蔽评论功能， 1comments: false 菜单中添加链接，编辑主题配置文件，解注释 1categories &emsp;&emsp;(tags页面类似)]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假面饭店]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%81%87%E9%9D%A2%E9%A5%AD%E5%BA%97%2F</url>
    <content type="text"><![CDATA[饭店人员一边想象着客人的本来面目，一边还必须要尊重他们的假面具，决不能试图摘下来。因为某种程度上，客人是为了享受面具舞会才来的饭店。 &emsp;&emsp;这本书和他之前的作品一样，阅读过程十分顺畅，多少有点欲罢不能。故事结构完整，情节设计精巧，但是推理节奏较为拖沓；最终决战到来之前的风雨欲来的紧迫感营造的很优秀，但是最终的杀人动机极为狗血。&emsp;&emsp;作者在主线情节的中间还穿插着一些支线情节，这些段落插曲一方面丰满了人物，另一方面也促进了情节的推动，每一个小故事或多或少的提供了一点线索。经纬度和环形密码还是比较有趣的。&emsp;&emsp;印象最深的还是男女主角对于工作的高度责任心。两个完全不相关的职业以及思考方式，在推理判断过程中的成长，从开始的互不理解到互相欣赏，在推理之余增加了温情。&emsp;&emsp;可能是因为之前看的东野的小说都太过经典和优秀（白夜行，解忧杂货铺等），所以对这本书阅读体验并不如期待。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
</search>
