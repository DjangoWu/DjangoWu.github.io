<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java和C++的二进制文件问题]]></title>
    <url>%2F2018%2F03%2F24%2FJava%E5%92%8CC-%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[项目需要用到用Java读取C++生成的二进制文件，直接读取时存在错误。 因为需要考虑机器的大小端问题，Java程序采用的是大端字节序(左高右低), 而C++采用的是小端字节序(左低右高)。因此在读取数据时候需要转换下。 C++代码:123456789101112// 在c++中,用二进制方式写入数值 int main(int argc, char* argv[])&#123; ofstream outfile("c:\\d1.dat"); float f = 12.5f; outfile.write((char *)&amp;f,sizeof(float)); f = 3332.5f; outfile.write((char *)&amp;f,sizeof(float)); f = 1442.5224f; outfile.write((char *)&amp;f,sizeof(float)); outfile.close(); return 0; &#125; Java代码:1234567public static void main(String[] args) throws Exception &#123; File f = new File("c:/d1.dat"); CppInputStream dis = new CppInputStream(new FileInputStream(f)); System.out.println(dis.readFloat()); System.out.println(dis.readFloat()); System.out.println(dis.readFloat()); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108// 参见java.io.DataInputStream // C++写入的字节顺序是从低到高（左低到右高）， // 而java.io.DataInputStream读取的数据是从高到低（左高到右低) // 所以需要自己改写一下 public class CppInputStream extends FilterInputStream &#123; public CppInputStream(InputStream in) &#123; super(in); &#125; public final int read(byte b[]) throws IOException &#123; return in.read(b, 0, b.length); &#125; public final int read(byte b[], int off, int len) throws IOException &#123; return in.read(b, off, len); &#125; public final void readFully(byte b[]) throws IOException &#123; readFully(b, 0, b.length); &#125; public final void readFully(byte b[], int off, int len) throws IOException &#123; if (len &lt; 0) throw new IndexOutOfBoundsException(); int n = 0; while (n &lt; len) &#123; int count = in.read(b, off + n, len - n); if (count &lt; 0) throw new EOFException(); n += count; &#125; &#125; public final int skipBytes(int n) throws IOException &#123; int total = 0; int cur = 0; while ((total &lt; n) &amp;&amp; ((cur = (int) in.skip(n - total)) &gt; 0)) &#123; total += cur; &#125; return total; &#125; public final byte readByte() throws IOException &#123; int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return (byte) (ch); &#125; public final int readUnsignedByte() throws IOException &#123; int ch = in.read(); if (ch &lt; 0) throw new EOFException(); return ch; &#125; public final short readShort() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (short) ((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); &#125; public final int readUnsignedShort() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0); &#125; public final char readChar() throws IOException &#123; int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2) &lt; 0) throw new EOFException(); return (char) ((ch1 &lt;&lt; 8) + (ch2 &lt;&lt; 0)); &#125; public final int readInt() throws IOException &#123; int ch4 = in.read(); int ch3 = in.read(); int ch2 = in.read(); int ch1 = in.read(); if ((ch1 | ch2 | ch3 | ch4) &lt; 0) throw new EOFException(); return ((ch1 &lt;&lt; 24) + (ch2 &lt;&lt; 16) + (ch3 &lt;&lt; 8) + (ch4 &lt;&lt; 0)); &#125; private byte readBuffer[] = new byte[8]; public final long readLong() throws IOException &#123; readFully(readBuffer, 0, 8); return (((long) readBuffer[7] &lt;&lt; 56) + ((long) (readBuffer[6] &amp; 255) &lt;&lt; 48) + ((long) (readBuffer[5] &amp; 255) &lt;&lt; 40) + ((long) (readBuffer[4] &amp; 255) &lt;&lt; 32) + ((long) (readBuffer[3] &amp; 255) &lt;&lt; 24) + ((readBuffer[2] &amp; 255) &lt;&lt; 16) + ((readBuffer[1] &amp; 255) &lt;&lt; 8) + ((readBuffer[0] &amp; 255) &lt;&lt; 0)); &#125; public final float readFloat() throws IOException &#123; return Float.intBitsToFloat(readInt()); &#125; public final double readDouble() throws IOException &#123; return Double.longBitsToDouble(readLong()); &#125; &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode解题报告]]></title>
    <url>%2F2018%2F03%2F17%2FLeetCode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[Stay hungry, stay foolishUntil 2018-03-24 19:36:43, I have solved 136 / 718 problems while 133 are still locked. Completion statistic: C++: 135 Python: 1 Solution: 68 Note: :lock: means you need to buy from LeetCode LeetCode Solution Table ID Title Difficulty C++ Python Solution 001 Two Sum Easy C++ To Do solution 002 Add Two Numbers Medium C++ To Do To Do 003 Longest Substring Without Repeating Characters Medium C++ To Do To Do 004 Median of Two Sorted Arrays Hard To Do To Do To Do 005 Longest Palindromic Substring Medium C++ To Do solution 006 ZigZag Conversion Medium To Do To Do To Do 007 Reverse Integer Easy C++ To Do To Do 008 String to Integer (atoi) Medium To Do To Do To Do 009 Palindrome Number Easy C++ To Do solution 010 Regular Expression Matching Hard To Do To Do To Do 011 Container With Most Water Medium To Do To Do To Do 012 Integer to Roman Medium To Do To Do To Do 013 Roman to Integer Easy C++ To Do To Do 014 Longest Common Prefix Easy To Do To Do To Do 015 3Sum Medium C++ To Do solution 016 3Sum Closest Medium C++ To Do solution 017 Letter Combinations of a Phone Number Medium To Do To Do To Do 018 4Sum Medium C++ To Do solution 019 Remove Nth Node From End of List Medium To Do To Do To Do 020 Valid Parentheses Easy To Do To Do To Do 021 Merge Two Sorted Lists Easy C++ To Do solution 022 Generate Parentheses Medium C++ To Do To Do 023 Merge k Sorted Lists Hard To Do To Do To Do 024 Swap Nodes in Pairs Medium C++ To Do To Do 025 Reverse Nodes in k-Group Hard To Do To Do To Do 026 Remove Duplicates from Sorted Array Easy C++ To Do solution 027 Remove Element Easy C++ To Do solution 028 Implement strStr() Easy C++ To Do To Do 029 Divide Two Integers Medium To Do To Do To Do 030 Substring with Concatenation of All Words Hard To Do To Do To Do 031 Next Permutation Medium C++ To Do solution 032 Longest Valid Parentheses Hard To Do To Do To Do 033 Search in Rotated Sorted Array Medium To Do To Do To Do 034 Search for a Range Medium C++ To Do solution 035 Search Insert Position Easy C++ To Do solution 036 Valid Sudoku Medium To Do To Do To Do 037 Sudoku Solver Hard To Do To Do To Do 038 Count and Say Easy To Do To Do To Do 039 Combination Sum Medium C++ To Do solution 040 Combination Sum II Medium To Do To Do To Do 041 First Missing Positive Hard To Do To Do To Do 042 Trapping Rain Water Hard To Do To Do To Do 043 Multiply Strings Medium To Do To Do To Do 044 Wildcard Matching Hard To Do To Do To Do 045 Jump Game II Hard To Do To Do To Do 046 Permutations Medium To Do To Do To Do 047 Permutations II Medium To Do To Do To Do 048 Rotate Image Medium To Do To Do To Do 049 Group Anagrams Medium To Do To Do To Do 050 Pow(x, n) Medium C++ To Do To Do 051 N-Queens Hard To Do To Do To Do 052 N-Queens II Hard To Do To Do To Do 053 Maximum Subarray Easy To Do To Do To Do 054 Spiral Matrix Medium To Do To Do To Do 055 Jump Game Medium C++ To Do solution 056 Merge Intervals Medium To Do To Do To Do 057 Insert Interval Hard To Do To Do To Do 058 Length of Last Word Easy To Do To Do To Do 059 Spiral Matrix II Medium C++ To Do To Do 060 Permutation Sequence Medium To Do To Do To Do 061 Rotate List Medium To Do To Do To Do 062 Unique Paths Medium To Do To Do To Do 063 Unique Paths II Medium To Do To Do To Do 064 Minimum Path Sum Medium To Do To Do To Do 065 Valid Number Hard To Do To Do To Do 066 Plus One Easy C++ To Do solution 067 Add Binary Easy C++ To Do solution 068 Text Justification Hard To Do To Do To Do 069 Sqrt(x) Easy C++ To Do To Do 070 Climbing Stairs Easy To Do To Do To Do 071 Simplify Path Medium To Do To Do To Do 072 Edit Distance Hard To Do To Do To Do 073 Set Matrix Zeroes Medium To Do To Do To Do 074 Search a 2D Matrix Medium C++ To Do solution 075 Sort Colors Medium To Do To Do To Do 076 Minimum Window Substring Hard To Do To Do To Do 077 Combinations Medium To Do To Do To Do 078 Subsets Medium To Do To Do To Do 079 Word Search Medium To Do To Do To Do 080 Remove Duplicates from Sorted Array II Medium C++ To Do solution 081 Search in Rotated Sorted Array II Medium To Do To Do To Do 082 Remove Duplicates from Sorted List II Medium To Do To Do To Do 083 Remove Duplicates from Sorted List Easy To Do To Do To Do 084 Largest Rectangle in Histogram Hard C++ To Do solution 085 Maximal Rectangle Hard C++ To Do solution 086 Partition List Medium To Do To Do To Do 087 Scramble String Hard To Do To Do To Do 088 Merge Sorted Array Easy C++ To Do To Do 089 Gray Code Medium C++ To Do To Do 090 Subsets II Medium To Do To Do To Do 091 Decode Ways Medium To Do To Do To Do 092 Reverse Linked List II Medium To Do To Do To Do 093 Restore IP Addresses Medium To Do To Do To Do 094 Binary Tree Inorder Traversal Medium To Do To Do To Do 095 Unique Binary Search Trees II Medium To Do To Do To Do 096 Unique Binary Search Trees Medium C++ To Do solution 097 Interleaving String Hard To Do To Do To Do 098 Validate Binary Search Tree Medium C++ To Do solution 099 Recover Binary Search Tree Hard C++ To Do solution 100 Same Tree Easy C++ To Do solution 101 Symmetric Tree Easy C++ To Do solution 102 Binary Tree Level Order Traversal Medium C++ To Do solution 103 Binary Tree Zigzag Level Order Traversal Medium C++ To Do solution 104 Maximum Depth of Binary Tree Easy C++ To Do solution 105 Construct Binary Tree from Preorder and Inorder Traversal Medium C++ To Do solution 106 Construct Binary Tree from Inorder and Postorder Traversal Medium C++ To Do solution 107 Binary Tree Level Order Traversal II Easy C++ To Do solution 108 Convert Sorted Array to Binary Search Tree Easy To Do To Do To Do 109 Convert Sorted List to Binary Search Tree Medium To Do To Do To Do 110 Balanced Binary Tree Easy C++ To Do solution 111 Minimum Depth of Binary Tree Easy C++ To Do solution 112 Path Sum Easy C++ To Do solution 113 Path Sum II Medium C++ To Do solution 114 Flatten Binary Tree to Linked List Medium C++ To Do solution 115 Distinct Subsequences Hard To Do To Do To Do 116 Populating Next Right Pointers in Each Node Medium C++ To Do solution 117 Populating Next Right Pointers in Each Node II Medium C++ To Do solution 118 Pascal’s Triangle Easy C++ To Do solution 119 Pascal’s Triangle II Easy C++ To Do solution 120 Triangle Medium To Do To Do To Do 121 Best Time to Buy and Sell Stock Easy To Do To Do To Do 122 Best Time to Buy and Sell Stock II Easy To Do To Do To Do 123 Best Time to Buy and Sell Stock III Hard To Do To Do To Do 124 Binary Tree Maximum Path Sum Hard To Do To Do To Do 125 Valid Palindrome Easy C++ To Do solution 126 Word Ladder II Hard To Do To Do To Do 127 Word Ladder Medium To Do To Do To Do 128 Longest Consecutive Sequence Hard To Do To Do To Do 129 Sum Root to Leaf Numbers Medium C++ To Do solution 130 Surrounded Regions Medium To Do To Do To Do 131 Palindrome Partitioning Medium To Do To Do To Do 132 Palindrome Partitioning II Hard To Do To Do To Do 133 Clone Graph Medium To Do To Do To Do 134 Gas Station Medium To Do To Do To Do 135 Candy Hard To Do To Do To Do 136 Single Number Easy C++ To Do To Do 137 Single Number II Medium To Do To Do To Do 138 Copy List with Random Pointer Medium To Do To Do To Do 139 Word Break Medium To Do To Do To Do 140 Word Break II Hard To Do To Do To Do 141 Linked List Cycle Easy C++ To Do To Do 142 Linked List Cycle II Medium To Do To Do To Do 143 Reorder List Medium To Do To Do To Do 144 Binary Tree Preorder Traversal Medium To Do To Do To Do 145 Binary Tree Postorder Traversal Hard To Do To Do To Do 146 LRU Cache Hard To Do To Do To Do 147 Insertion Sort List Medium To Do To Do To Do 148 Sort List Medium To Do To Do To Do 149 Max Points on a Line Hard To Do To Do To Do 150 Evaluate Reverse Polish Notation Medium To Do To Do To Do 151 Reverse Words in a String Medium To Do To Do To Do 152 Maximum Product Subarray Medium C++ To Do To Do 153 Find Minimum in Rotated Sorted Array Medium C++ To Do solution 154 Find Minimum in Rotated Sorted Array II Hard C++ To Do solution 155 Min Stack Easy C++ To Do solution 156 Binary Tree Upside Down :lock: Medium To Do To Do To Do 157 Read N Characters Given Read4 :lock: Easy To Do To Do To Do 158 Read N Characters Given Read4 II - Call multiple times :lock: Hard To Do To Do To Do 159 Longest Substring with At Most Two Distinct Characters :lock: Hard To Do To Do To Do 160 Intersection of Two Linked Lists Easy To Do To Do To Do 161 One Edit Distance :lock: Medium To Do To Do solution 162 Find Peak Element Medium C++ To Do solution 163 Missing Ranges :lock: Medium To Do To Do To Do 164 Maximum Gap Hard To Do To Do To Do 165 Compare Version Numbers Medium C++ To Do To Do 166 Fraction to Recurring Decimal Medium C++ To Do solution 167 Two Sum II - Input array is sorted Easy C++ To Do To Do 168 Excel Sheet Column Title Easy To Do To Do To Do 169 Majority Element Easy To Do To Do To Do 170 Two Sum III - Data structure design :lock: Easy To Do To Do To Do 171 Excel Sheet Column Number Easy C++ To Do solution 172 Factorial Trailing Zeroes Easy C++ Python solution 173 Binary Search Tree Iterator Medium C++ To Do solution 174 Dungeon Game Hard To Do To Do To Do 179 Largest Number Medium C++ To Do To Do 186 Reverse Words in a String II :lock: Medium To Do To Do To Do 187 Repeated DNA Sequences Medium To Do To Do To Do 188 Best Time to Buy and Sell Stock IV Hard To Do To Do To Do 189 Rotate Array Easy To Do To Do To Do 190 Reverse Bits Easy To Do To Do To Do 191 Number of 1 Bits Easy C++ To Do solution 198 House Robber Easy To Do To Do To Do 199 Binary Tree Right Side View Medium To Do To Do To Do 200 Number of Islands Medium To Do To Do To Do 201 Bitwise AND of Numbers Range Medium To Do To Do To Do 202 Happy Number Easy To Do To Do To Do 203 Remove Linked List Elements Easy To Do To Do To Do 204 Count Primes Easy C++ To Do To Do 205 Isomorphic Strings Easy To Do To Do To Do 206 Reverse Linked List Easy To Do To Do To Do 207 Course Schedule Medium To Do To Do To Do 208 Implement Trie (Prefix Tree) Medium C++ To Do To Do 209 Minimum Size Subarray Sum Medium C++ To Do solution 210 Course Schedule II Medium To Do To Do To Do 211 Add and Search Word - Data structure design Medium To Do To Do To Do 212 Word Search II Hard To Do To Do To Do 213 House Robber II Medium To Do To Do To Do 214 Shortest Palindrome Hard To Do To Do To Do 215 Kth Largest Element in an Array Medium C++ To Do solution 216 Combination Sum III Medium To Do To Do To Do 217 Contains Duplicate Easy To Do To Do To Do 218 The Skyline Problem Hard To Do To Do To Do 219 Contains Duplicate II Easy To Do To Do To Do 220 Contains Duplicate III Medium To Do To Do To Do 221 Maximal Square Medium C++ To Do To Do 222 Count Complete Tree Nodes Medium To Do To Do To Do 223 Rectangle Area Medium To Do To Do To Do 224 Basic Calculator Hard To Do To Do To Do 225 Implement Stack using Queues Easy To Do To Do To Do 226 Invert Binary Tree Easy To Do To Do To Do 227 Basic Calculator II Medium C++ To Do solution 228 Summary Ranges Medium To Do To Do To Do 229 Majority Element II Medium To Do To Do To Do 230 Kth Smallest Element in a BST Medium To Do To Do To Do 231 Power of Two Easy C++ To Do solution 232 Implement Queue using Stacks Easy To Do To Do To Do 233 Number of Digit One Hard C++ To Do To Do 234 Palindrome Linked List Easy To Do To Do To Do 235 Lowest Common Ancestor of a Binary Search Tree Easy To Do To Do To Do 236 Lowest Common Ancestor of a Binary Tree Medium To Do To Do To Do 237 Delete Node in a Linked List Easy To Do To Do To Do 238 Product of Array Except Self Medium To Do To Do To Do 239 Sliding Window Maximum Hard To Do To Do To Do 240 Search a 2D Matrix II Medium To Do To Do To Do 241 Different Ways to Add Parentheses Medium To Do To Do To Do 242 Valid Anagram Easy C++ To Do To Do 243 Shortest Word Distance :lock: Easy To Do To Do To Do 244 Shortest Word Distance II :lock: Medium To Do To Do To Do 245 Shortest Word Distance III :lock: Medium To Do To Do To Do 246 Strobogrammatic Number :lock: Easy To Do To Do To Do 247 Strobogrammatic Number II :lock: Medium To Do To Do To Do 248 Strobogrammatic Number III :lock: Hard To Do To Do To Do 249 Group Shifted Strings :lock: Medium To Do To Do To Do 250 Count Univalue Subtrees :lock: Medium To Do To Do To Do 251 Flatten 2D Vector :lock: Medium To Do To Do To Do 252 Meeting Rooms :lock: Easy To Do To Do To Do 253 Meeting Rooms II :lock: Medium To Do To Do To Do 254 Factor Combinations :lock: Medium To Do To Do To Do 255 Verify Preorder Sequence in Binary Search Tree :lock: Medium To Do To Do To Do 256 Paint House :lock: Easy To Do To Do To Do 257 Binary Tree Paths Easy C++ To Do solution 258 Add Digits Easy To Do To Do To Do 259 3Sum Smaller :lock: Medium To Do To Do To Do 260 Single Number III Medium C++ To Do To Do 261 Graph Valid Tree :lock: Medium To Do To Do To Do 263 Ugly Number Easy C++ To Do To Do 264 Ugly Number II Medium To Do To Do To Do 265 Paint House II :lock: Hard To Do To Do To Do 266 Palindrome Permutation :lock: Easy To Do To Do To Do 267 Palindrome Permutation II :lock: Medium To Do To Do To Do 268 Missing Number Easy C++ To Do solution 269 Alien Dictionary :lock: Hard To Do To Do To Do 270 Closest Binary Search Tree Value :lock: Easy To Do To Do To Do 271 Encode and Decode Strings :lock: Medium To Do To Do To Do 272 Closest Binary Search Tree Value II :lock: Hard To Do To Do To Do 273 Integer to English Words Hard To Do To Do To Do 274 H-Index Medium To Do To Do To Do 275 H-Index II Medium To Do To Do To Do 276 Paint Fence :lock: Easy To Do To Do To Do 277 Find the Celebrity :lock: Medium To Do To Do To Do 278 First Bad Version Easy To Do To Do To Do 279 Perfect Squares Medium C++ To Do solution 280 Wiggle Sort :lock: Medium To Do To Do To Do 281 Zigzag Iterator :lock: Medium To Do To Do To Do 282 Expression Add Operators Hard C++ To Do solution 283 Move Zeroes Easy To Do To Do To Do 284 Peeking Iterator Medium To Do To Do To Do 285 Inorder Successor in BST :lock: Medium To Do To Do To Do 286 Walls and Gates :lock: Medium To Do To Do To Do 287 Find the Duplicate Number Medium To Do To Do To Do 288 Unique Word Abbreviation :lock: Medium To Do To Do To Do 289 Game of Life Medium To Do To Do To Do 290 Word Pattern Easy To Do To Do To Do 291 Word Pattern II :lock: Hard To Do To Do To Do 292 Nim Game Easy C++ To Do To Do 293 Flip Game :lock: Easy To Do To Do To Do 294 Flip Game II :lock: Medium To Do To Do To Do 295 Find Median from Data Stream Hard To Do To Do To Do 296 Best Meeting Point :lock: Hard To Do To Do To Do 297 Serialize and Deserialize Binary Tree Hard To Do To Do To Do 298 Binary Tree Longest Consecutive Sequence :lock: Medium To Do To Do To Do 299 Bulls and Cows Medium C++ To Do To Do 300 Longest Increasing Subsequence Medium To Do To Do To Do 301 Remove Invalid Parentheses Hard To Do To Do To Do 302 Smallest Rectangle Enclosing Black Pixels :lock: Hard To Do To Do To Do 303 Range Sum Query - Immutable Easy C++ To Do To Do 304 Range Sum Query 2D - Immutable Medium To Do To Do To Do 305 Number of Islands II :lock: Hard To Do To Do To Do 306 Additive Number Medium To Do To Do To Do 307 Range Sum Query - Mutable Medium C++ To Do To Do 308 Range Sum Query 2D - Mutable :lock: Hard To Do To Do To Do 309 Best Time to Buy and Sell Stock with Cooldown Medium To Do To Do To Do 310 Minimum Height Trees Medium To Do To Do To Do 311 Sparse Matrix Multiplication :lock: Medium To Do To Do To Do 312 Burst Balloons Hard To Do To Do To Do 313 Super Ugly Number Medium To Do To Do To Do 314 Binary Tree Vertical Order Traversal :lock: Medium To Do To Do To Do 315 Count of Smaller Numbers After Self Hard To Do To Do To Do 316 Remove Duplicate Letters Hard To Do To Do To Do 317 Shortest Distance from All Buildings :lock: Hard To Do To Do To Do 318 Maximum Product of Word Lengths Medium To Do To Do To Do 319 Bulb Switcher Medium To Do To Do To Do 320 Generalized Abbreviation :lock: Medium To Do To Do To Do 321 Create Maximum Number Hard To Do To Do To Do 322 Coin Change Medium To Do To Do To Do 323 Number of Connected Components in an Undirected Graph :lock: Medium To Do To Do To Do 324 Wiggle Sort II Medium To Do To Do To Do 325 Maximum Size Subarray Sum Equals k :lock: Medium To Do To Do To Do 326 Power of Three Easy To Do To Do To Do 327 Count of Range Sum Hard To Do To Do To Do 328 Odd Even Linked List Medium To Do To Do To Do 329 Longest Increasing Path in a Matrix Hard C++ To Do To Do 330 Patching Array Hard To Do To Do To Do 331 Verify Preorder Serialization of a Binary Tree Medium C++ To Do solution 332 Reconstruct Itinerary Medium To Do To Do To Do 333 Largest BST Subtree :lock: Medium To Do To Do To Do 334 Increasing Triplet Subsequence Medium To Do To Do To Do 335 Self Crossing Hard To Do To Do To Do 336 Palindrome Pairs Hard To Do To Do To Do 337 House Robber III Medium C++ To Do solution 338 Counting Bits Medium C++ To Do To Do 339 Nested List Weight Sum :lock: Easy To Do To Do To Do 340 Longest Substring with At Most K Distinct Characters :lock: Hard To Do To Do To Do 341 Flatten Nested List Iterator Medium To Do To Do To Do 342 Power of Four Easy To Do To Do To Do 343 Integer Break Medium To Do To Do To Do 344 Reverse String Easy C++ To Do To Do 345 Reverse Vowels of a String Easy To Do To Do To Do 346 Moving Average from Data Stream :lock: Easy To Do To Do To Do 347 Top K Frequent Elements Medium To Do To Do To Do 348 Design Tic-Tac-Toe :lock: Medium To Do To Do To Do 349 Intersection of Two Arrays Easy C++ To Do To Do 350 Intersection of Two Arrays II Easy To Do To Do To Do 351 Android Unlock Patterns :lock: Medium To Do To Do To Do 352 Data Stream as Disjoint Intervals Hard To Do To Do To Do 353 Design Snake Game :lock: Medium To Do To Do To Do 354 Russian Doll Envelopes Hard To Do To Do To Do 355 Design Twitter Medium To Do To Do To Do 356 Line Reflection :lock: Medium To Do To Do To Do 357 Count Numbers with Unique Digits Medium C++ To Do To Do 358 Rearrange String k Distance Apart :lock: Hard To Do To Do To Do 359 Logger Rate Limiter :lock: Easy To Do To Do To Do 360 Sort Transformed Array :lock: Medium To Do To Do To Do 361 Bomb Enemy :lock: Medium To Do To Do To Do 362 Design Hit Counter :lock: Medium To Do To Do To Do 363 Max Sum of Rectangle No Larger Than K Hard C++ To Do To Do 364 Nested List Weight Sum II :lock: Medium To Do To Do To Do 365 Water and Jug Problem Medium To Do To Do To Do 366 Find Leaves of Binary Tree :lock: Medium To Do To Do To Do 367 Valid Perfect Square Easy To Do To Do To Do 368 Largest Divisible Subset Medium C++ To Do To Do 369 Plus One Linked List :lock: Medium To Do To Do To Do 370 Range Addition :lock: Medium To Do To Do To Do 371 Sum of Two Integers Easy C++ To Do To Do 372 Super Pow Medium To Do To Do To Do 373 Find K Pairs with Smallest Sums Medium To Do To Do To Do 374 Guess Number Higher or Lower Easy C++ To Do To Do 375 Guess Number Higher or Lower II Medium To Do To Do To Do 376 Wiggle Subsequence Medium C++ To Do To Do 377 Combination Sum IV Medium To Do To Do To Do 378 Kth Smallest Element in a Sorted Matrix Medium To Do To Do To Do 379 Design Phone Directory :lock: Medium To Do To Do To Do 380 Insert Delete GetRandom O(1) Medium To Do To Do To Do 381 Insert Delete GetRandom O(1) - Duplicates allowed Hard To Do To Do To Do 382 Linked List Random Node Medium To Do To Do To Do 383 Ransom Note Easy To Do To Do To Do 384 Shuffle an Array Medium C++ To Do To Do 385 Mini Parser Medium To Do To Do To Do 386 Lexicographical Numbers Medium To Do To Do To Do 387 First Unique Character in a String Easy C++ To Do To Do 388 Longest Absolute File Path Medium To Do To Do To Do 389 Find the Difference Easy To Do To Do To Do 390 Elimination Game Medium C++ To Do To Do 391 Perfect Rectangle Hard To Do To Do To Do 392 Is Subsequence Medium To Do To Do To Do 393 UTF-8 Validation Medium To Do To Do To Do 394 Decode String Medium To Do To Do To Do 395 Longest Substring with At Least K Repeating Characters Medium C++ To Do To Do 396 Rotate Function Medium To Do To Do To Do 397 Integer Replacement Medium C++ To Do solution 398 Random Pick Index Medium To Do To Do To Do 399 Evaluate Division Medium C++ To Do To Do 400 Nth Digit Easy To Do To Do To Do 401 Binary Watch Easy C++ To Do To Do 402 Remove K Digits Medium To Do To Do To Do 403 Frog Jump Hard To Do To Do To Do 404 Sum of Left Leaves Easy C++ To Do solution 405 Convert a Number to Hexadecimal Easy To Do To Do To Do 406 Queue Reconstruction by Height Medium To Do To Do To Do 407 Trapping Rain Water II Hard To Do To Do To Do 408 Valid Word Abbreviation :lock: Easy To Do To Do To Do 409 Longest Palindrome Easy To Do To Do To Do 410 Split Array Largest Sum Hard C++ To Do To Do 411 Minimum Unique Word Abbreviation :lock: Hard To Do To Do To Do 412 Fizz Buzz Easy To Do To Do To Do 413 Arithmetic Slices Medium To Do To Do To Do 414 Third Maximum Number Easy To Do To Do To Do 415 Add Strings Easy To Do To Do To Do 416 Partition Equal Subset Sum Medium To Do To Do To Do 417 Pacific Atlantic Water Flow Medium To Do To Do To Do 418 Sentence Screen Fitting :lock: Medium To Do To Do To Do 419 Battleships in a Board Medium To Do To Do To Do 420 Strong Password Checker Hard To Do To Do To Do 421 Maximum XOR of Two Numbers in an Array Medium To Do To Do To Do 422 Valid Word Square :lock: Easy To Do To Do To Do 423 Reconstruct Original Digits from English Medium To Do To Do To Do 424 Longest Repeating Character Replacement Medium To Do To Do To Do 425 Word Squares :lock: Hard To Do To Do To Do 432 All O`one Data Structure Hard To Do To Do To Do 434 Number of Segments in a String Easy C++ To Do To Do 435 Non-overlapping Intervals Medium To Do To Do To Do 436 Find Right Interval Medium To Do To Do To Do 437 Path Sum III Easy To Do To Do To Do 438 Find All Anagrams in a String Easy To Do To Do To Do 439 Ternary Expression Parser :lock: Medium To Do To Do To Do 440 K-th Smallest in Lexicographical Order Hard To Do To Do To Do 441 Arranging Coins Easy To Do To Do To Do 442 Find All Duplicates in an Array Medium C++ To Do To Do 443 String Compression Easy To Do To Do To Do 444 Sequence Reconstruction :lock: Medium To Do To Do To Do 445 Add Two Numbers II Medium C++ To Do To Do 446 Arithmetic Slices II - Subsequence Hard To Do To Do To Do 447 Number of Boomerangs Easy C++ To Do To Do 448 Find All Numbers Disappeared in an Array Easy To Do To Do To Do 449 Serialize and Deserialize BST Medium To Do To Do To Do 450 Delete Node in a BST Medium To Do To Do To Do 451 Sort Characters By Frequency Medium To Do To Do To Do 452 Minimum Number of Arrows to Burst Balloons Medium To Do To Do To Do 453 Minimum Moves to Equal Array Elements Easy To Do To Do To Do 454 4Sum II Medium To Do To Do To Do 455 Assign Cookies Easy C++ To Do To Do 456 132 Pattern Medium To Do To Do To Do 459 Repeated Substring Pattern Easy To Do To Do To Do 460 LFU Cache Hard To Do To Do To Do 461 Hamming Distance Easy C++ To Do To Do 462 Minimum Moves to Equal Array Elements II Medium C++ To Do To Do 463 Island Perimeter Easy To Do To Do To Do 464 Can I Win Medium To Do To Do To Do 465 Optimal Account Balancing :lock: Hard To Do To Do To Do 466 Count The Repetitions Hard To Do To Do To Do 467 Unique Substrings in Wraparound String Medium To Do To Do To Do 468 Validate IP Address Medium To Do To Do To Do 469 Convex Polygon :lock: Medium To Do To Do To Do 471 Encode String with Shortest Length :lock: Hard To Do To Do To Do 472 Concatenated Words Hard To Do To Do To Do 473 Matchsticks to Square Medium C++ To Do solution 474 Ones and Zeroes Medium To Do To Do To Do 475 Heaters Easy To Do To Do To Do 476 Number Complement Easy To Do To Do To Do 477 Total Hamming Distance Medium To Do To Do To Do 479 Largest Palindrome Product Easy To Do To Do To Do 480 Sliding Window Median Hard To Do To Do To Do 481 Magical String Medium To Do To Do To Do 482 License Key Formatting Easy To Do To Do To Do 483 Smallest Good Base Hard To Do To Do To Do 484 Find Permutation :lock: Medium To Do To Do To Do 485 Max Consecutive Ones Easy C++ To Do To Do 486 Predict the Winner Medium To Do To Do To Do 487 Max Consecutive Ones II :lock: Medium To Do To Do To Do 488 Zuma Game Hard To Do To Do To Do 490 The Maze :lock: Medium To Do To Do To Do 491 Increasing Subsequences Medium To Do To Do To Do 492 Construct the Rectangle Easy To Do To Do To Do 493 Reverse Pairs Hard To Do To Do To Do 494 Target Sum Medium To Do To Do To Do 495 Teemo Attacking Medium To Do To Do To Do 496 Next Greater Element I Easy To Do To Do To Do 498 Diagonal Traverse Medium To Do To Do To Do 499 The Maze III :lock: Hard To Do To Do To Do 500 Keyboard Row Easy C++ To Do To Do 501 Find Mode in Binary Search Tree Easy C++ To Do To Do 502 IPO Hard To Do To Do To Do 503 Next Greater Element II Medium To Do To Do To Do 504 Base 7 Easy C++ To Do To Do 505 The Maze II :lock: Medium To Do To Do To Do 506 Relative Ranks Easy To Do To Do To Do 507 Perfect Number Easy To Do To Do To Do 508 Most Frequent Subtree Sum Medium To Do To Do To Do 513 Find Bottom Left Tree Value Medium To Do To Do To Do 514 Freedom Trail Hard To Do To Do To Do 515 Find Largest Value in Each Tree Row Medium To Do To Do To Do 516 Longest Palindromic Subsequence Medium To Do To Do To Do 517 Super Washing Machines Hard To Do To Do To Do 520 Detect Capital Easy C++ To Do To Do 521 Longest Uncommon Subsequence I Easy To Do To Do To Do 522 Longest Uncommon Subsequence II Medium To Do To Do To Do 523 Continuous Subarray Sum Medium To Do To Do To Do 524 Longest Word in Dictionary through Deleting Medium To Do To Do To Do 525 Contiguous Array Medium To Do To Do To Do 526 Beautiful Arrangement Medium To Do To Do To Do 527 Word Abbreviation :lock: Hard To Do To Do To Do 529 Minesweeper Medium To Do To Do To Do 530 Minimum Absolute Difference in BST Easy C++ To Do To Do 531 Lonely Pixel I :lock: Medium To Do To Do To Do 532 K-diff Pairs in an Array Easy C++ To Do solution 533 Lonely Pixel II :lock: Medium To Do To Do To Do 535 Encode and Decode TinyURL Medium To Do To Do To Do 536 Construct Binary Tree from String :lock: Medium To Do To Do To Do 537 Complex Number Multiplication Medium To Do To Do To Do 538 Convert BST to Greater Tree Easy C++ To Do To Do 539 Minimum Time Difference Medium To Do To Do To Do 540 Single Element in a Sorted Array Medium To Do To Do To Do 541 Reverse String II Easy To Do To Do To Do 542 01 Matrix Medium To Do To Do To Do 543 Diameter of Binary Tree Easy To Do To Do To Do 544 Output Contest Matches :lock: Medium To Do To Do To Do 545 Boundary of Binary Tree :lock: Medium To Do To Do To Do 546 Remove Boxes Hard To Do To Do To Do 547 Friend Circles Medium To Do To Do To Do 548 Split Array with Equal Sum :lock: Medium To Do To Do To Do 549 Binary Tree Longest Consecutive Sequence II :lock: Medium To Do To Do To Do 551 Student Attendance Record I Easy C++ To Do To Do 552 Student Attendance Record II Hard To Do To Do To Do 553 Optimal Division Medium To Do To Do To Do 554 Brick Wall Medium To Do To Do To Do 555 Split Concatenated Strings :lock: Medium To Do To Do To Do 556 Next Greater Element III Medium To Do To Do To Do 557 Reverse Words in a String III Easy C++ To Do To Do 560 Subarray Sum Equals K Medium To Do To Do To Do 561 Array Partition I Easy To Do To Do To Do 562 Longest Line of Consecutive One in Matrix :lock: Medium To Do To Do To Do 563 Binary Tree Tilt Easy To Do To Do To Do 564 Find the Closest Palindrome Hard To Do To Do To Do 565 Array Nesting Medium To Do To Do To Do 566 Reshape the Matrix Easy To Do To Do To Do 567 Permutation in String Medium To Do To Do To Do 568 Maximum Vacation Days :lock: Hard To Do To Do To Do 572 Subtree of Another Tree Easy To Do To Do To Do 573 Squirrel Simulation :lock: Medium To Do To Do To Do 575 Distribute Candies Easy To Do To Do To Do 576 Out of Boundary Paths Medium To Do To Do To Do 581 Shortest Unsorted Continuous Subarray Easy To Do To Do To Do 582 Kill Process :lock: Medium To Do To Do To Do 583 Delete Operation for Two Strings Medium C++ To Do To Do 587 Erect the Fence Hard To Do To Do To Do 588 Design In-Memory File System :lock: Hard To Do To Do To Do 591 Tag Validator Hard To Do To Do To Do 592 Fraction Addition and Subtraction Medium To Do To Do To Do 593 Valid Square Medium To Do To Do To Do 594 Longest Harmonious Subsequence Easy To Do To Do To Do 598 Range Addition II Easy To Do To Do To Do 599 Minimum Index Sum of Two Lists Easy To Do To Do To Do 600 Non-negative Integers without Consecutive Ones Hard To Do To Do To Do 604 Design Compressed String Iterator :lock: Easy To Do To Do To Do 605 Can Place Flowers Easy C++ To Do To Do 606 Construct String from Binary Tree Easy To Do To Do To Do 609 Find Duplicate File in System Medium To Do To Do To Do 611 Valid Triangle Number Medium C++ To Do solution 616 Add Bold Tag in String :lock: Medium To Do To Do To Do 617 Merge Two Binary Trees Easy To Do To Do To Do 621 Task Scheduler Medium To Do To Do To Do 623 Add One Row to Tree Medium To Do To Do To Do 624 Maximum Distance in Arrays :lock: Easy To Do To Do To Do 625 Minimum Factorization :lock: Medium To Do To Do To Do 628 Maximum Product of Three Numbers Easy C++ To Do To Do 629 K Inverse Pairs Array Hard To Do To Do To Do 630 Course Schedule III Hard To Do To Do To Do 631 Design Excel Sum Formula :lock: Hard To Do To Do To Do 632 Smallest Range Hard C++ To Do To Do 633 Sum of Square Numbers Easy To Do To Do To Do 634 Find the Derangement of An Array :lock: Medium To Do To Do To Do 635 Design Log Storage System :lock: Medium To Do To Do To Do 636 Exclusive Time of Functions Medium To Do To Do To Do 637 Average of Levels in Binary Tree Easy To Do To Do To Do 638 Shopping Offers Medium To Do To Do To Do 639 Decode Ways II Hard To Do To Do To Do 640 Solve the Equation Medium To Do To Do To Do 642 Design Search Autocomplete System :lock: Hard To Do To Do To Do 643 Maximum Average Subarray I Easy To Do To Do To Do 644 Maximum Average Subarray II :lock: Hard To Do To Do To Do 645 Set Mismatch Easy To Do To Do To Do 646 Maximum Length of Pair Chain Medium To Do To Do To Do 647 Palindromic Substrings Medium C++ To Do To Do 648 Replace Words Medium C++ To Do To Do 649 Dota2 Senate Medium To Do To Do To Do 650 2 Keys Keyboard Medium To Do To Do To Do 651 4 Keys Keyboard :lock: Medium To Do To Do To Do 652 Find Duplicate Subtrees Medium To Do To Do To Do 653 Two Sum IV - Input is a BST Easy To Do To Do To Do 654 Maximum Binary Tree Medium To Do To Do To Do 655 Print Binary Tree Medium To Do To Do To Do 656 Coin Path :lock: Hard To Do To Do To Do 657 Judge Route Circle Easy To Do To Do To Do 658 Find K Closest Elements Medium To Do To Do To Do 659 Split Array into Consecutive Subsequences Medium To Do To Do To Do 660 Remove 9 :lock: Hard To Do To Do To Do 661 Image Smoother Easy To Do To Do To Do 662 Maximum Width of Binary Tree Medium To Do To Do To Do 663 Equal Tree Partition :lock: Medium To Do To Do To Do 664 Strange Printer Hard To Do To Do To Do 665 Non-decreasing Array Easy To Do To Do To Do 666 Path Sum IV :lock: Medium To Do To Do To Do 667 Beautiful Arrangement II Medium To Do To Do To Do 668 Kth Smallest Number in Multiplication Table Hard To Do To Do To Do 669 Trim a Binary Search Tree Easy To Do To Do To Do 670 Maximum Swap Medium To Do To Do To Do 671 Second Minimum Node In a Binary Tree Easy To Do To Do To Do 672 Bulb Switcher II Medium To Do To Do To Do 673 Number of Longest Increasing Subsequence Medium To Do To Do To Do 674 Longest Continuous Increasing Subsequence Easy To Do To Do To Do 675 Cut Off Trees for Golf Event Hard To Do To Do To Do 676 Implement Magic Dictionary Medium To Do To Do To Do 677 Map Sum Pairs Medium To Do To Do To Do 678 Valid Parenthesis String Medium To Do To Do To Do 679 24 Game Hard To Do To Do To Do 680 Valid Palindrome II Easy To Do To Do To Do 681 Next Closest Time :lock: Medium To Do To Do To Do 682 Baseball Game Easy To Do To Do To Do 683 K Empty Slots :lock: Hard To Do To Do To Do 684 Redundant Connection Medium To Do To Do To Do 685 Redundant Connection II Hard To Do To Do To Do 686 Repeated String Match Easy To Do To Do To Do 687 Longest Univalue Path Easy C++ To Do solution 688 Knight Probability in Chessboard Medium To Do To Do To Do 689 Maximum Sum of 3 Non-Overlapping Subarrays Hard To Do To Do To Do 690 Employee Importance Easy To Do To Do To Do 691 Stickers to Spell Word Hard To Do To Do To Do 692 Top K Frequent Words Medium To Do To Do To Do 693 Binary Number with Alternating Bits Easy To Do To Do To Do 694 Number of Distinct Islands :lock: Medium To Do To Do To Do 695 Max Area of Island Easy To Do To Do To Do 696 Count Binary Substrings Easy To Do To Do To Do 697 Degree of an Array Easy To Do To Do To Do 698 Partition to K Equal Sum Subsets Medium To Do To Do To Do 699 Falling Squares Hard To Do To Do To Do 711 Number of Distinct Islands II :lock: Hard To Do To Do To Do 712 Minimum ASCII Delete Sum for Two Strings Medium To Do To Do To Do 713 Subarray Product Less Than K Medium To Do To Do To Do 714 Best Time to Buy and Sell Stock with Transaction Fee Medium To Do To Do To Do 715 Range Module Hard To Do To Do To Do 716 Max Stack :lock: Hard To Do To Do To Do 717 1-bit and 2-bit Characters Easy To Do To Do To Do 718 Maximum Length of Repeated Subarray Medium To Do To Do To Do 719 Find K-th Smallest Pair Distance Hard To Do To Do To Do 720 Longest Word in Dictionary Easy To Do To Do To Do 721 Accounts Merge Medium To Do To Do To Do 722 Remove Comments Medium To Do To Do To Do 723 Candy Crush :lock: Medium To Do To Do To Do 724 Find Pivot Index Easy To Do To Do To Do 725 Split Linked List in Parts Medium To Do To Do To Do 726 Number of Atoms Hard To Do To Do To Do 727 Minimum Window Subsequence :lock: Hard To Do To Do To Do 728 Self Dividing Numbers Easy To Do To Do To Do 729 My Calendar I Medium To Do To Do To Do 730 Count Different Palindromic Subsequences Hard To Do To Do To Do 731 My Calendar II Medium To Do To Do To Do 732 My Calendar III Hard To Do To Do To Do 733 Flood Fill Easy To Do To Do To Do 734 Sentence Similarity :lock: Easy To Do To Do To Do 735 Asteroid Collision Medium To Do To Do To Do 736 Parse Lisp Expression Hard To Do To Do To Do 737 Sentence Similarity II :lock: Medium To Do To Do To Do 738 Monotone Increasing Digits Medium To Do To Do To Do 739 Daily Temperatures Medium To Do To Do To Do 740 Delete and Earn Medium To Do To Do To Do 741 Cherry Pickup Hard To Do To Do To Do 742 Closest Leaf in a Binary Tree :lock: Medium To Do To Do To Do 743 Network Delay Time Medium To Do To Do To Do 744 Find Smallest Letter Greater Than Target Easy To Do To Do To Do 745 Prefix and Suffix Search Hard To Do To Do To Do 746 Min Cost Climbing Stairs Easy To Do To Do To Do 747 Largest Number At Least Twice of Others Easy To Do To Do To Do 748 Shortest Completing Word Medium To Do To Do To Do 749 Contain Virus Hard To Do To Do To Do 750 Number Of Corner Rectangles :lock: Medium To Do To Do To Do 751 IP to CIDR :lock: Easy To Do To Do To Do 752 Open the Lock Medium To Do To Do To Do 753 Cracking the Safe Hard To Do To Do To Do 754 Reach a Number Medium To Do To Do To Do 755 Pour Water :lock: Medium To Do To Do To Do 756 Pyramid Transition Matrix Medium To Do To Do To Do 757 Set Intersection Size At Least Two Hard To Do To Do To Do 758 Bold Words in String :lock: Easy To Do To Do To Do 759 Employee Free Time :lock: Hard To Do To Do To Do 760 Find Anagram Mappings :lock: Easy To Do To Do To Do 761 Special Binary String Hard To Do To Do To Do 762 Prime Number of Set Bits in Binary Representation Easy To Do To Do To Do 763 Partition Labels Medium To Do To Do To Do 764 Largest Plus Sign Medium To Do To Do To Do 765 Couples Holding Hands Hard To Do To Do To Do 766 Toeplitz Matrix Easy To Do To Do To Do 767 Reorganize String Medium To Do To Do To Do 768 Max Chunks To Make Sorted II Hard To Do To Do To Do 769 Max Chunks To Make Sorted Medium To Do To Do To Do 770 Basic Calculator IV Hard To Do To Do To Do 771 Jewels and Stones Easy To Do To Do To Do 772 Basic Calculator III :lock: Hard To Do To Do To Do 773 Sliding Puzzle Hard To Do To Do To Do 774 Minimize Max Distance to Gas Station :lock: Hard To Do To Do To Do 775 Global and Local Inversions Medium To Do To Do To Do 776 Split BST :lock: Medium To Do To Do To Do 777 Swap Adjacent in LR String Medium To Do To Do To Do 778 Swim in Rising Water Hard To Do To Do To Do 779 K-th Symbol in Grammar Medium To Do To Do To Do 780 Reaching Points Hard To Do To Do To Do 781 Rabbits in Forest Medium To Do To Do To Do 782 Transform to Chessboard Hard To Do To Do To Do 783 Minimum Distance Between BST Nodes Easy To Do To Do To Do 784 Letter Case Permutation Easy To Do To Do To Do 785 Is Graph Bipartite? Medium To Do To Do To Do 786 K-th Smallest Prime Fraction Hard To Do To Do To Do 787 Cheapest Flights Within K Stops Medium To Do To Do To Do 788 Rotated Digits Easy To Do To Do To Do 789 Escape The Ghosts Medium To Do To Do To Do 790 Domino and Tromino Tiling Medium To Do To Do To Do 791 Custom Sort String Medium To Do To Do To Do 792 Number of Matching Subsequences Medium To Do To Do To Do 793 Preimage Size of Factorial Zeroes Function Hard To Do To Do To Do 794 Valid Tic-Tac-Toe State Medium To Do To Do To Do 795 Number of Subarrays with Bounded Maximum Medium To Do To Do To Do 796 Rotate String Easy To Do To Do To Do 797 All Paths From Source to Target Medium To Do To Do To Do 798 Smallest Rotation with Highest Score Hard To Do To Do To Do 799 Champagne Tower Medium To Do To Do To Do 800 Similar RGB Color :lock: Easy To Do To Do To Do 801 Minimum Swaps To Make Sequences Increasing Medium To Do To Do To Do 802 Find Eventual Safe States Medium To Do To Do To Do 803 Bricks Falling When Hit Hard To Do To Do To Do]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++学习搜索备忘]]></title>
    <url>%2F2018%2F03%2F16%2FC-%E5%AD%A6%E4%B9%A0%E6%90%9C%E7%B4%A2%E5%A4%87%E5%BF%98%2F</url>
    <content type="text"><![CDATA[lambda使用Lambda表达式C++ Lambda表达式基本用法 语法： [ captures ] (可选)(C++20) ( params ) specifiers(可选) exception attr -&gt; ret requires(可选)(C++20) { body }[ captures ] ( params ) -&gt; ret { body }[ captures ] ( params ) { body }[ captures ] { body } std::make_shared的用处std::make_shared有啥用 程序使用动态内存的原因： 程序不知道自己需要多少对象 程序不知道所需对象的准确类型 程序需要在多个对象间共享数据 shared_ptr的用法: 可以指向特定类型的对象，用于自动释放所指的对象make_shared的用法：在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr，与智能指针相同，定义在memory中。 12345shared_ptr&lt;CDlgPointCloud&gt; PointCloudDlgPointer;//指向类型为CDlgPointCloud的对象PointCloudDlgPointer;make_shared&lt;int&gt; p3 = make_shared&lt;int&gt;(42)；// 一般使用auto来保存auto p1 =make_shared&lt;int&gt;(42); 关于std::move和std::forward理解std::move和std::forward std::move和std::forward只不过就是执行cast的两个函数（实际上是函数模板）。std::move无条件地把它的参数转换成一个右值，而std::forward只在特定条件满足的情况下执行这个转换。 右值引用和转移语义右值引用与转移语义 右值引用是用来支持转移语义的。转移语义可以将资源(堆，系统对象等)从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高C++应用程序的性能。临时对象的维护(创建和销毁)对性能有严重影响。转移语义和拷贝语义是相对的，可类比文件的剪切和拷贝。编译器只对右值引用才能调用转移构造函数和赋值函数，而所有命名对象都只能是左值引用，若已知一个命名对象不再被引用而想对它调用转移构造函数和转移赋值函数，也就是把一个左值引用当做右值引用来使用：标准库提供了函数std::move，该函数以非常简单的方式将左值引用转换为右值引用。 C++常见预定义宏 FILE：文件名 LINE：行数 FUNCTION：函数名称 DATE, TIME：最后一次编译的时间和日期(字符串形式) TIMESTAMP：与TIME格式相同，用于得到本文件最后一次被修改的时间 VERSION：用于得到编译器的版本 I/O：std::ios_base::openmode std::ios_base::in：打开文件进行读操作，即读取文件中的数据 std::ios_base::out：打开文件进行写操作，即写入数据到文件 std::ios_base::in | std::ios_base::out: 打开文件进行读写操作 std::ios_base::app: 每次进行写入操作的时候都会重新定位到文件的末尾 std::ios_base::ate: 打开文件之后立即定位到文件末尾 std::ios_base::trunc: 打开文件，若文件已存在那么，清空文件内容 std::ios_base::binary: 以二进制的方式对打开的文件进行读写 C++文件读写C++文件读写详解（ofstream,ifstream,fstream）]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译boost库(VS2015)]]></title>
    <url>%2F2018%2F03%2F16%2F%E7%BC%96%E8%AF%91boost%E5%BA%93-VS2015%2F</url>
    <content type="text"><![CDATA[下载并解压Boost下载地址 编译32位的boost库 编译：msvc版本14.0对应的是vs2015，–stagedir是指定编译后存放的目录。1bjam stage --toolset=msvc-14.0 --without-graph --without-graph_parallel --stagedir=&quot;C:\Boost\boost_1_66_0\bin\vc14&quot; link=static runtime-link=shared runtime-link=static threading=multi debug release 编译64位的boost库1bjam stage --toolset=msvc-14.0 architecture=x86 address-model=64 --without-graph --without-graph_parallel --stagedir=&quot;D:\boost\boost_1_63_0\bin\vc14-x64&quot; link=static runtime-link=shared runtime-link=static threading=multi debug release 项目中使用VS项目中添加包含目录和库目录即可]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让子弹飞一会儿]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF%2F</url>
    <content type="text"><![CDATA[你说是钱对我重要，还是你对我重要你和钱对我都不重要，没有你，对我很重要 &emsp;&emsp;虽然这只是我看的姜文的第二部电影，但是在我心中已经可以把他和王小波一样捧到天上去了。前面一部看的是《鬼子来了》，尽管很多人说国民的劣根性，但是我还是为我民族的善良淳朴落泪。 &emsp;&emsp;因为涉及一些政治因素，《鬼子来了》被禁；《太阳照常升起》又因为一些晦涩难懂的隐喻而票房不佳。影评人或者观众或多或少总会有些怀疑姜文的导演能力，这些不认同的声音在他的心里挥之不去。所以这部片子他做出了一些改变，在我看来，一方面既能表达他心中想要表现的观点和情感，另一方便也是为了破除格局获得认同，按其电影里的话来说就是“站着也把钱赚了”(张和冯的电影大多向资本妥协)。从最后的票房结果和影片后续的评论看来，他也确实做到了。 &emsp;&emsp;关于人物关于情节不想多说，人各有见，豆瓣知乎也是有一大堆讨论的。想说的主要是自己对于这部片子和对于姜文的感受。 &emsp;&emsp;在影片中很多地方都能看到姜文的英雄主义情怀，比如松坡将军及小凤仙。不清楚姜文为何对民国时代情有独钟，或许是因为这个动荡的历史时期能有更多的材料能更好的抒发情绪吧。对于角色的名字也是颇为讲究，张牧之(张麻子)、武智冲、马邦德这几个带着或是隐喻或是恶趣味的名字也能让人为之一笑。 &emsp;&emsp;说下印象最深刻的几场戏： 小六子为了自证清白，不想说他中二，只是看到他最后死去的时候，心好像被什么抓住了似得，除了对这个有血性的少年的心疼之外，剩下的也只有对于一哄而散的看客和强权者及畏于强权者的愤怒。 三个影帝同台飙戏，据说是拍了好几十次才完成的，也难怪如此耐看，不管是镜头的转换还是台词对于人物的勾勒对于情节的推动都无可挑剔。有人说是因为姜文对葛优说剧组里有发哥，对发哥说剧组里有葛优才把这两人凑到了一起，且不论真假，能看到这三位出现在同一个大荧幕上就够开心了。 叹号之后的问号，两个简简单单的符号很容易的就表达了其对于革命的必要性以及革命之后的路要怎么走(抑或是对于革命后)的困惑。 “上海就是浦东，浦东就是上海”。 &emsp;&emsp;借用豆瓣上一个影评中的两句话作为结尾吧： 在其最纯粹的意义上，只要贫穷和等级制依然存在，革命就永无止息。然而对于大多数人而言，革命之后，应当是世俗生活的开始，而不是继续革命，更不是永远革命。 于是，一切血与火最终都淹没在湖光山色掩映中的那首《送别》之中，火车开向七十年后改革开放的浦东，尾随的骑士沿着铁轨独行成一个孤绝的背影。这一切，像一个开始，又像一个结尾，更像是一个轮回。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>让子弹飞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python作用域和命名空间示例]]></title>
    <url>%2F2018%2F01%2F15%2FPython%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以下示例演示了如何引用不同作用域和命名空间，以及global和nonlocal如何影响变量绑定：12345678910111213141516171819def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) &emsp;&emsp;输出为：1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 注意：local赋值语句无法改变scope_test的spam绑定。nonlocal赋值语句改变了scope_test的spam绑定，并且global赋值语句从模块级改变了spam绑定。(global赋值语句之前对spam是没有预先绑定的)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码风格]]></title>
    <url>%2F2018%2F01%2F10%2Fpython%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于python，PEP8引入了大多数项目遵循的风格指导。给出了一个高度可读，视觉友好的编码风格。下面是一些关键要点： 使用4空格缩进，而非TAB在小缩进(可以嵌套更深)和大缩进(更易读)之间，4空格是一个较好的折中。TAB引发了一些混乱，最好弃用。 折行以确保其不会超过79字符 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后边，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 同一函数和类命名 推荐类名用驼峰命名函数和方法名用小写_和_下划线 。总是用self作为方法的第一个参数 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的ASCII总是工作的最好 同样，也不要使用非ASCII字符的标识符，除非是不同语种的会阅读或者维护代码]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win必备工具]]></title>
    <url>%2F2018%2F01%2F10%2Fwin%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.Sublime Text&emsp;&emsp;下载地址：Sublime Text&emsp;&emsp;参考博客 最爱的一款文本编辑器，可安装多种插件 2.Cmder&emsp;&emsp;下载地址：Cmder&emsp;&emsp;参考博客 比windows原生cmd好出了天际，支持PowerShell，完全版本自带git。 3.Launchy&emsp;&emsp;下载地址：Launchy 免费开源快速启动软件 安装简易，按alt+space启动 多种皮肤可供选用 提供了一些插件扩展 还可以自定义目录及文件 4.MacType&emsp;&emsp;下载地址：Mactype 改善Windows字体渲染 热替换系统默认字体 &emsp;&emsp;MacType自带了多种配置文件，根据需要选择即可。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++(第三版)读书笔记]]></title>
    <url>%2F2018%2F01%2F10%2FEffective%20C%2B%2B(%E7%AC%AC%E4%B8%89%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 让自己习惯C++(Accustoming Yourself to C++)条款01：视C++为一个语言联邦(View C++ as a federation of languages) C。C++以C为基础。区块(blocks)、语句(statements)、预处理器(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)。 Object-Oriented C++。classes(包括构造函数和析构函数)，封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual函数(动态绑定)…… Template C++。C++的泛型编程(generic programing)部分。 STL。STL是个template程序库。它对容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象的规约有极佳的紧密配合与协调。 &emsp;&emsp;记住这四个次语言，每个次语言都有自己的规约(视情况而定)。 条款02. 尽量以const，enum，inline替换#define(Prefer consts, enums, and inlines to #defines) 对于单纯常量，最好以const对象或enums替换#define。 对于形似函数的宏(macros)，最好改用inline函数替换#defines。 条款03. 尽可能使用const(Use const whenever possible)&emsp;&emsp;const允许你指定一个语义约束(指定一个“不该被改动”的对象)，而编译器会强制实施这项约束。将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。1234567// 如果const出现在星号左边，表示被指物是常量；// 如果const出现在星号右边，表示指针本身是常量；char greeting[] = "Hello";char* p = greeting; // non-const pointer, non-const dataconst char* p = greeting; // non-const pointer, const datachar* const p = greeting; // const pointer, non-const dataconst char* const p = greeting; // const pointer, const data &emsp;&emsp;如果希望STL迭代器所指的东西不可被改动(即希望STL模拟一个const T*指针)，需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin(); // iter的作用像个T* const*iter = 10; // 没问题，改变iter所指物++iter; // 错误！iter是constconst std::vector&lt;int&gt;::const_iterator citer = vec.begin(); // citer的作用像个const T**citer = 10; // 错误！*citer是const++citer; // 没问题，改变cIter const成员函数&emsp;&emsp;将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。重要原因有两点: 使得class接口比较容易被理解。因为，得知哪个函数可以改动对象内容而哪个不行，是很重要的。 使得“操作const对象”成为可能。 条款04. 确定对象被使用前已先被初始化(Make sure that objects are initialized before they are used) 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 2.构造/析构/赋值运算(Constructors, Destructors, and Assignment Operators)条款05. 了解C++默默编写并调用哪些函数(Know what functions C++ silently writes and calls) 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符、以及析构函数。 &emsp;&emsp;如果你写下：1class Empty &#123; &#125;; &emsp;&emsp;实际上是：12345678class Empty &#123;public: Empty() &#123;...&#125; // default构造函数 Empty(const Empty&amp; rhs) &#123;...&#125; // copy构造函数 ~Empty() &#123;...&#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125;// copy assignment操作符&#125;; &emsp;&emsp;如果本身声明了构造函数，编译器就不再为它创建default构造函数。 条款06. 若不想使用编译器自动生成的函数，就该明确拒绝(Explicitly disallow the use of compiler-generated functions you do not want.) 为驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为private并且不予实现。使用Uncopyable这样的base class也是一种做法。 1234567891011121314151617181920212223// Solution 1：class HomeForSale &#123;public: ...private: ... HomeForSale(const HomeForSale&amp;); // 只有声明 HomeForSale&amp; operator=(const HomeForSale&amp;); &#125;;// Solution 2:class Uncopyable &#123; // 允许derived对象构造和析构protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable&amp;)； // 但阻止copying Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;// 为求阻止HomeForSale对象被拷贝，唯一需要做的是继承Uncopyable:class HomeForSale: private Uncopyable &#123; // class 不在声明 ... // copy构造函数或&#125;; // copy assign 操作符 条款07. 为多态基类声明virtual析构函数(Declare destructors virtual in polymorphic base classes.)&emsp;&emsp;(多态性质情况下)为防止出现“局部销毁”对象，造成资源泄露等结果，需要给base class一个virtual析构函数。伺候删除derived class对象就会销毁整个对象，包括derived class成分：123456789class TimeKeeper &#123;public: TimeKeeper(); virtual ~TimeKeeper(); ...&#125;;TimeKeeper* ptk = getTimeKeeper();...delete ptk; // 现在，行为正确 如果class不含virtual函数，通常表示它并不意图被用做一个base class。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 条款08. 别让异常逃离析构函数(Prevent exceptions from leaving destructors) 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行该操作。 条款09. 绝不在构造和析构过程中调用virtual函数(Never call virtual functions during construction or destruction.) 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。 条款10. 令operator= 返回一个reference to *this(Have assigment operators return a reference to *this.)123456789class Widget &#123;public: Widget&amp; operator+=(const Widget&amp; rhs) &#123; ... return* this; &#125; ...&#125;; &emsp;&emsp;注意，这只是个协议，并无强制性。 条款11. 在operator= 中处理“自我赋值”(Handle assignment to self in operator=.) 确保当对象自我赋值时operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 123456789101112131415161718192021222324252627282930class Bitmap &#123;...&#125;;// 1.比较(证同测试)Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if (this == &amp;rhs) return *this; // 证同测试 // 如果是自我赋值，就不做任何事 delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 2.语句顺序Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; // 记住原先的pb pb = new Bitmap(*rhs.pb); // 令pb指向*pb的一个复件(副本) delete pOrig; // 删除原先的pb return *this;&#125;// 3.copy-and-swapclass Widget &#123; ... void swap(Widget&amp; rhs); //交换*this和rhs的数据; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); // 将*this数据和上述复件的数据交换 return *this;&#125; 条款12. 复制对象时勿忘其每一个成分(Copy all parts of an object.)&emsp;&emsp;设计良好之面向对象系统(OO-system)会将对象的内部封装起来，只留两个函数负责对象拷贝(复制)，就是copy构造函数和copy assignment操作符(即为copying函数)。&emsp;&emsp;任何时候只要你承担起“为derived class撰写copying函数”的重责大任，必须很小心地也复制器base class成分。那些成分往往是private，所以无法直接访问它们，你应该让derived class的copying函数调用相应的base class函数。 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。 不要尝试某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中(如init函数)，并由两个copying函数共同调用。 3.资源管理(Resource Management) 内存只是必须管理的众多资源之一，其他常见的资源还包括文件描述器(file descriptors)、互斥锁(mutex locks)、图形界面中的字型和笔刷、数据库连接、以及网络sockets。 条款13. 以对象管理资源(Use objects to manage resources.)123456void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment( )); // 调用factory函数 ... // 一如既往地使用pInv&#125; // 经由auto_ptr的析构甘薯自动删除pInv &emsp;&emsp;这个简单例子示范了“以对象管理资源”的两个关键想法： 获得资源后立刻放进管理对象内。以上代码中createInvestment返回的资源被当作其管理者auto_ptr的初值。实际上“以对象管理资源”的观念常备称为“资源取得时机便是初始化时机”(Resource Acquisition Is Initialization;RAII)。 管理对象运用析构函数确保资源被释放。 &emsp;&emsp;注意auto_ptrs有一个性质：若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权！123std::auto_ptr&lt;Investment&gt; pInv1(createInvestment( )); // pInv1指向createInvestment返回物std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // 现在pInv2指向对象，pInv1被设为nullpInv1 = pInv2; // pInv2被设为null &emsp;&emsp;使用tr1::shared_ptrs比auto_ptrs的复制正常一些。 为防止资源泄露，清使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。 两个常备使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它(被复制物)指向null。 条款14. 在资源管理类中小心copying行为(Think carefully behavior in resource-managing classes.)&emsp;&emsp;RAII守则“资源在构造期间获得，在析构期间释放”。 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法(reference counting)。不过其他行为也都可能被实现。 条款15. 在资源管理类中提供对原始资源的访问(Provide access to raw resources in resource-managing classes.) APIs往往要求访问原始资源(raw resources)，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显式转换或者隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。 条款16. 成对使用new和delete时要采取相同形式(Use the same form in corresponding uses of new and delete) 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 条款17. 以独立语句将newed对象置入智能指针(Store newed objects in smart pointers in standalone statements.)12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // 在单独语句内以只能指针存储newed所得对象processWidget(pw, priority()); // 这个调用动作决不至于造成泄露 以独立语句将newed对象存储于(置入)智能指针中。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 4. 设计与声明(Designs and Declarations) 让接口容易被正确使用，不容易被误用(正确性、高效性、封装性、维护性、延展性、以及协议的一致性)。 条款18. 让接口容易被正确使用，不易被误用(Make interfaces easy to use correctly and hard to use incorrectly.) 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的方法包括建立新类型、限制类型上的操作、束缚对象值、以及消除客户的资源管理责任。 tr1::shared_ptr支持定制型删除器(custom deleter)。这可防范DLL问题，可被用来自动解除互斥锁等等。 条款19. 设计class犹如设计type(Treat class design as type design) 新type的对象应该如何被创建和销毁？ 对象的初始化和对象的赋值该有什么样的差别？ 新type的对象如果被passed by value，意味着什么？ 什么是新type的“合法值”？ 你的新type需要配合某个继承图系(inheritance graph)吗？ 你的新type需要什么样的转换？ 什么样的操作符和函数对此新type而言是合理的？ 什么样的标准函数应该驳回？ 谁该取用新type的成员？ 什么是新type的“未声明接口”(undeclared interface)？ 你的新type有多么一般化？ 你真的需要一个新type吗？ 条款20. 宁以pass-by-reference-to-const替换pass-by-value&emsp;&emsp;缺省情况下C++以by value方式传递对象至函数。 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题(slicing problem)。 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。 条款21. 必须返回对象时，别妄想返回其reference(Don’t try to return a reference when you must return an object.)&emsp;&emsp;一个“必须返回新对象”的函数的正确写法是让其返回一个新对象。1234inline const Rational operator * (const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.n * rhs.n, lhs.d * rhs.d);&#125; 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。 条款22. 将成员变量声明为private(Declare data members private.) 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。 protected并不比public更具封装性。 条款23. 宁以non-member、non-friend替换member函数 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性(packaging flexibility)和机能扩充性。 条款24. 若所有参数皆需类型转换，请为此采用non-member函数(Declare non-member functions when type conversions should apply to all parameters.) 如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换，那么这个函数必须是non-member。 条款25. 考虑写出一个不抛出异常的swap函数(Consider support for a non-throwing swap.) 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。 如果你提供一个member swap，特该提供一个non-member swap用来调用前者。对于classes(而非templates)，也请特化std::swap。 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。 为“用户定义类型”进行std templates全特化是最好的，但千万不要尝试在std内加入某些对std而言全新的东西。 5. 实现(Implementations)&emsp;&emsp;太快定义变量可能造成效率上的拖延；过渡使用转型(casts)可能导致代码变慢又难维护，又找来微妙难解的错误；返回对象“内部数据之号码牌(handles)”可能会破坏封装并留给客户虚吊号码牌(danling handles)；未考虑异常带来的冲击则可能导致资源泄露和数据败坏；过渡热心地inlining可能引起代码膨胀；过渡耦合(coupling)则可能导致让人不满意的冗长建置时间(build times)。 条款26. 尽可能延后变量定义式的出现时间(Postpone variable definitions as long as possible.)&emsp;&emsp;不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初始实参为止。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的default构造行为。 条款27. 尽量少做转型动作(Minimize casting.)&emsp;&emsp;C++提供了四种新式转型(new-style/C++-style casts)123456789// 旧式 old-style casts(T)expression //将expression转型为TT(expression) //~// new-styleconst_cast&lt;T&gt;( expression )dynamic_cast&lt;T&gt;( expression )reinterpret_cast&lt;T&gt;( expression )static_cast&lt;T&gt;( expression ) &emsp;&emsp;各有不同的目的： const_cast通常被用来将对象的常量性移除(cast away the constness)。也是唯一有此能力的 C++-style转型操作符。 dynamic_cast主要用来执行“安全向下转型”(safe downcasting)，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。 reinterpret_cast意图执行低级转型，实际动作及结果可能取决于编译器，也就是说它不可移植。 static_cast用来强迫隐式转换(implicit conversions)，例如将non-const对象转为const对象等。它也可以用来执行上述多种转换的反向转换，但无法将const转为non-const。 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。 宁可使用C++-style(新式)转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的德州的执掌。 条款28. 避免返回handles指向对象内部成分(Avoid returning “handles” to object internals.) 成员变量的封装性最多只能等于“返回其reference”的函数的访问级别。 如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。&emsp;&emsp;如果返回的是指针或迭代器，相同的情况还是发生，原因也相同。References、指针和迭代器都是所谓的handles 避免返回handles(包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”(dangling handles)的可能性降至最低。 条款29. 为“异常安全”而努力是值得的(Strive for exception-safe code.)&emsp;&emsp;当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 &emsp;&emsp;异常安全函数(Exception-safe functions)提供以下三个保证之一： 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，任何对象都处于一种内部前后一致的状态(例如所有的class约束条件都继续获得满足)。 强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。 不抛掷(nothrow)保证：承诺绝不抛出异常，因为它们总能够完成它们原先承诺的功能。作用于内置类型(例如ints，指针等等)身上的所有操作都提供nothrow保证。 异常安全函数(Exception-safe functions)即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证中的最弱者”。 条款30. 透彻了解inlining的里里外外(Understand the ins and outs of inlining.)&emsp;&emsp;80-20经验法则：平均而言一个程序往往将80%的执行时间花费在20%的代码上。 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability)更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。 条款31. 将文件间的编译依存关系降至最低(Minimize compilation dependencies between files.)&emsp;&emsp;编译依存性最小化的本质：显示中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式(而非定义式)相依： 如果使用object references 或 object pointers可以完成任务，就不要使用objects。 如果能够，尽量以class声明式替换class定义式。 为声明式和定义式提供不同的头文件。 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。 程序库头文件应该以“完全且仅有声明式”(full and declaration-only forms)的形式存在。这种做法不论是否涉及templates都适用。 6 继承与面向对象设计(Inheritance and Object-Oriented Design.)条款32. 确定你的public继承塑模出is-a关系(Make sure public inheritance models “is-a.”) “public继承”以为is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。 条款33. 避免遮掩继承而来的名称(Avoid hiding inherited names.) derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwarding functions)。 条款34. 区分接口继承和实现继承(Differentiate between inheritance of interface and inheritance of implementation.)&emsp;&emsp;pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。而impure virtual函数会提供一份实现代码，derived classes可能覆写(override)它。一个non-virtual成员函数所表现的不变性(invariant)凌驾其特异性(specialization)，因为它表示不论derived class变得多么特异化，它的行为都不可以改变，也绝不该在derived class中被重新定义。 成员函数的接口总是会被继承。 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。 声明简朴的(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现。 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。 条款35. 考虑virtual函数以外的其他选择(Consider alternatives to virtual functions.) 使用non-virtual interface(NVI)手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected)的virtual函数。 将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。 以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物搭配一个兼容于需求的签名式。这也是Strategy设计模式的眸子形式。 将基础体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。 条款36. 绝不重新定义继承而来的non-virtual函数(Never redefine an inherited non-virtual function.)&emsp;&emsp;non-virtual函数实静态绑定的，如pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生之class”的对象；而virtual函数却是可以动态绑定的。 条款37. 绝不重新定义继承而来的缺省参数值(Never redefine a function’s inherited default parameter value.)&emsp;&emsp;virtual函数系动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值。 静态绑定：又名前期绑定(early binding) 静态类型(static type)：在程序中被声明时所采用的类型。 动态绑定：又名后期绑定(late binding) 动态类型(dynamic type):指的是“目前所指对象的类型”，也就是说，没动态类型可以表现出一个对象将会有什么行为。。 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数————你唯一应该覆写的东西————却是动态绑定。 条款38. 通过复合塑模出has-a或“根据某物实现出”(Model “has-a” or “is-implemented-in-terms-of” through composition.) 复合(composition)的意义和public继承完全不同。 在应用域(application domain)，复合意味has-a(有一个)。在实现域(implementation domain)，复合意味is-implemented-in-terms-of(根据某物实现出)。 条款39. 明智而审慎地使用private继承(Use private inheritance judiciously.) 如果classes之间的继承关系是private，编译器不会自动将一个derived class对象(例如Student)转换为一个base class对象(例如Person)。这和public继承不同。 由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性。 &emsp;&emsp;private继承意味着只有实现部分被继承，接口部分略去。 private继承意味is-implemented-in-terms of(根据某物实现出)。它通常比复合(composition)的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合(composition)不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。 条款40. 明智而审慎地使用多重继承(Use multiple inheritance judiciously.) 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。 7. 模板与泛型编程(Templates and Generic Programming.)(粗略阅读)条款41. 了解隐式接口和编译期多态(Understand implicit interfaces and compile-time polymorphism.) classes 和 templates都支持接口(interfaces)和多态(polymorphism)。 对classes而言接口是显式的(explicit)，以函数签名为中心。多态则是通过vvirtual函数发生于运行期。 对templa参数而言，接口是隐式的(implicit)，奠基于有效表达式。多态则是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。 条款42. 了解typename的双重意义(Understand the two meanings of typename.) 声明template参数时，前缀关键字class和typename可互换。 请使用关键字typename标识嵌套从属类型名称；但不得在base class lists(基类列)或member initialization list(成员初值列)内以它作为base class修饰符。 条款43. 学习处理模板化基类内的名称(Know how to access names in templatized base classes.) 可在derived class templates内通过“this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。 条款44. 将与参数无关的代码抽离templates(Factor parameter-independent code out of templates.) Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀，往往可降低，做法是让带有完全相同的二进制表述(binary representations)的具现类型(instantiation types)共享实现码。 条款45. 运用成员函数模板接受所有兼容类型(Use member function templates accept “all compatible types.”) 请使用member function templates(成员函数模板)生成“可接受所有兼容类型”的函数。 如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。 条款46. 需要声明类型转换时轻微模板定义非成员函数(Define non-member functions inside templates when type conversions are desired.) 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。 条款47. 请使用traits classes表现类型信息(Use traits classes for information about types.) Traits classes使得“类型相关信息”在编译器可用。它们以templates和“templates特化”完成实现。 整合重载技术(overloading)后，traits classes有可能在编译器对类型执行if…else测试。 条款48. 认识template元编程(Be aware of template metaprogramming.) Template metaprogramming(TMP，模板元编程)可将工作由运行期移往编译器，因而得以实现早期错误侦测和更高的执行效率。 TMP可被用来生成“基于政策选择组合”(based on combinations of policy choices)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 8. 定制new和delete(CUstomizing new and delete)(粗略阅读)条款49. 了解new-handler的行为(Understand the behavior of the new-handler.) set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。 条款50. 了解new和delete的合理替换时机(Understand when it makes sense to replace new and delete.) 有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。 条款51. 编写new和delete时需固守常规(Adhere to convention when writing new and delete.) operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 条款52.写了placement new也要写placement delete(Write placement delete if you write placement new.) 当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明placement new 和placement delete，请确定不要无意识(非故意)地遮掩了它们的正常版本。 9. 杂项讨论(Miscellany)条款53. 不要轻忽编译器的警告(Pay attention to compiler warnings.) 严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。 不要过度依赖编译器的报警能力，因为不同的编译器对待事物的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 条款54. 让自己熟悉包括TR1在内的标准程序库(Familiarize yourself with the standard library, including TR1.)&emsp;&emsp;C++98列入的C++标准程序库的主要成分： STL(Standard Template Library，标准模板库)，覆盖容器(containers如vector,string,map)、迭代器(iterator)、算法(algorithms如find，sort，transform)、函数对象(function objects如less，greater)、各种容器适配器(container adapters如stack，priority_queue)和函数对象适配器(function object adapters如mem_fun，not1)。Iostream，覆盖用户自定缓冲功能、国际化I/O，以及预先定义好的对象cin，cout，cerr和clog。国际化支持，包括多区域(multiple active locales)能力。像wchar_t(16bits/char)和wstring(wchar_ts组成的strings)等类型都对促进Unicode有所帮助，数值处理，包括复数模板(complex)和纯数值数组(valarray)。异常阶层体系(exception hierarchy)，包括base class exception及其derived classes logic_cerr和runtime_error，以及更深继承的各个classes。C89标准程序库。1989C标准程序库内的每个东西也都被覆盖于C++内。 &emsp;&emsp;TR1详细叙述了14个新组件(components，也就是程序库机能单位)，统统放在std命名空间内，更正确地说是在其嵌套命名空间tr1内。 智能指针(smart pointers) tr1::shared_ptr和tr1::weak_ptr。 tr1::function，此物得以表示任何callable entity(可调用物，也就是任何函数或函数对象)，只要其签名符合目标。 tr1::bind，它能够做STL绑定器(binders)bind1st和bind2nd所做的每一件事，而又更多。 Hash tables，用来实现sets，multisets，maps和multi-maps。 正则表达式(Regular expressions)，包括正则表达式为基础的字符串查找和替换，或是从某个匹配字符串到另一个匹配字符串的逐一迭代(iterator)等等。 Tuples(变量组)，这是标准程序库中的pair template的新一代制品。pair只能持有两个对象，tr1::tuple可持有任意个数的对象。 tr1::aray，本质上是个“STL化”数组，即一个支持成员函数如begin和end的数组。不过tr1::array的大小固定，并不适用动态内存。 tr1::mem_fn，这是个语气构造上与成员函数指针(member function pointers)一致的东西。 tr1::reference_wrapper，一个“让references的行为更像对象”的设施。它可以造成对象容器“犹如持有references”。 随机数(random number)生成工具，它大大超越了rand，那是C++继承自C标准程序库的一个函数。 数学特殊函数，包括Laguerre多项式、Bessel函数、完全椭圆积分(complete elliptic integrals)，以及更多数学函数。 C99兼容扩充。这是一大堆函数和模板，用来将许多新的C99程序库特性带进C++。 Type traits，一组traits classes，用于提供类型(types)的编译期信息。 tr1::result_of，这是个template，用来推到函数调用的返回类型。 C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。 TR1添加了智能指针(如tr1::shared_ptr)、一般化函数指针(tr1::function)、hash-based容器、正则表达式(regular expressions)以及另外是个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是Boost。 条款55：让自己熟悉Boost(Familiarize yourself with Boost.)&emsp;&emsp;Boost程序库对付的主题非常繁多，区分数十个类目，包括(程序库抽样)： 字符串与文本处理，覆盖具备类型安全(safe-type)的printf-like格式化动作、正则表达式，以及语汇单元切割(tokenizing)和解析(parsing)。 容器，覆盖“接口与STL相似且大小固定”的数组、大小可变的bitsets以及多位数组。 函数对象和高级编程，覆盖若干倍用来作为TR1机能基础的程序库。 泛型编程(Generic programming)，覆盖一大组traits classes。 模板元编程(Template metaprogramming, TMP)，覆盖一个针对编译器assertions而写的程序库，以及Boost MPL程序库。 数学与数值(Math and numerics)，包括有理数、八元数和四元数(octonions and quaternions)、常见的公约数(divisor)和少见的多重运算、随机数。 正确性与测试(Correctness and testing)，覆盖用来将隐式模板接口形式化的程序库，以及针对“测试优先”编程形态而设计的措施。 数据结构，覆盖类型安全和unions以及tuple程序库。 语言间的支持(Inter-language support)，包括允许C++和Python之间的无缝互操作性(seamless interoperability)。 内存，覆盖Pool程序库，用来做出高效率而区块大小固定的分配器，以及多变化的智能指针，包括TR1智能指针。 杂项，包括CRC检验、日期和时间的处理、在文件系统上来回移动等等。 Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。 Boost提供许多TR1组件实现品，以及其他许多程序库。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next配置]]></title>
    <url>%2F2018%2F01%2F05%2FHexo-Next%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 添加[关于][标签]等页面 hexo new page about hexo new page tags 2.头像设置&emsp;&emsp;修改站点配置文件，修改avatar,值设置成头像的链接或者地址1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 3. 圆形头像（添加旋转）&emsp;&emsp;Next主题默认不支持，修改source/css/_common/components/sidebar/sidebar-author.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 4.删除底部HEXO主题和主题&emsp;&emsp;修改\themes\next\layout_partials\footer.swig文件，删除:12345678910&lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt; 5.网站底部添加访问量&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件，在copyright前加上：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;然后再合适的位置添加显示统计的代码:12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &emsp;&emsp;这里有两种计算方式的统计代码: pv方式，单个用户连续点击n篇文章，记录n次访问量 uv方式，单个用户连续点击n篇文章，只记录1次访客量 6. 网站底部字数统计&emsp;&emsp;切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save &emsp;&emsp;然后在/themes/next/layout/_partials/footer.swig恰当位置添加： 1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 7.设置网站的图标Favicon&emsp;&emsp;在EasyIcon中找到适当的比例的ico图标，或者从别的网站下载或制作，并将名称修改为favicon.ico，然后将图标放在/themes/next/source/images，并修改主题配置文件：12345678favicon: small: /images/favicon.ico #favicon-16x16-next.png medium: /images/favicon.ico #favicon-32x32-next.png apple_touch_icon: /images/favicon.ico #apple-touch-icon-next.png safari_pinned_tab: /images/favicon.ico 8.实现统计功能&emsp;&emsp;在根目录下安装hexo-wordcount，运行1$ npm install hexo-wordcount --save &emsp;&emsp;然后在主题配置文件中，配置如下：1234post_wordcount: item_text: true wordcount: true min2read: true 9.添加顶部加载条&emsp;&emsp;修改主题配置文件，将pace: false改为pace: true即可，里面还内置了很多样式，可直接更换。 10.设置阅读全文 在文章中使用手动进行截断(推荐): 1&lt;!-- more --&gt; 在文章的front-matter中添加description，并提供文章摘录 自动形成摘要，在主题配置文件中添加：123auto_excerpt:enable: truelength: 150 11.文章打赏&emsp;&emsp;在文章开头添加reward: true，并修改主题配置页面：1234# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 12.返回顶部组件增加百分比&emsp;&emsp;在主题配置文件中修改scrollpercent 13.博文置顶&emsp;&emsp;将文件node_modules/hexo-generator-index/lib/generator.js中代码修改为12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; &emsp;&emsp;在文章中添加top值，数值越大，文章越靠前。 14.修改打赏字体不闪动&emsp;&emsp;修改文件123456789101112```/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 15.添加评论功能（liveRe 来必力）&emsp;&emsp;注册来必力，获取liver_uid，编辑主题配置文件，编辑livere_uid即可。 16.添加阅读次数&emsp;&emsp;注册LeanCloud 首先在应用创建一个应用，名字随意 然后在存储-&gt;数据中创建class，取名为Counter 在设置-&gt;应用Key中取得APP ID和APP Key 回到设置，选择安全中心，在Web安全域名中添加博客地址 &emsp;&emsp;修改主题配置文件:1234leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key 17. 修改文章底部带#标签&emsp;&emsp;修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 18. 修改文章内链接文本样式&emsp;&emsp;将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件themes\next\source\css_custom\custom.styl，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 19.搜索功能&emsp;&emsp;安装hexo-generator-searchdb，在站点根目录下执行1$ npm install hexo-generator-searchdb --save &emsp;&emsp;编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 &emsp;&emsp;修改主题配置文件：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 20.创建分类页面 新建一个页面， 1hexo new page categories 编辑新建的页面，增加 1type: categories 屏蔽评论功能， 1comments: false 菜单中添加链接，编辑主题配置文件，解注释 1categories &emsp;&emsp;(tags页面类似) 21.文章多个Tag分割 使用tags:[tag1, tag2]这样的形式即可。]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假面饭店]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%81%87%E9%9D%A2%E9%A5%AD%E5%BA%97%2F</url>
    <content type="text"><![CDATA[饭店人员一边想象着客人的本来面目，一边还必须要尊重他们的假面具，决不能试图摘下来。因为某种程度上，客人是为了享受面具舞会才来的饭店。 &emsp;&emsp;这本书和他之前的作品一样，阅读过程十分顺畅，多少有点欲罢不能。故事结构完整，情节设计精巧，但是推理节奏较为拖沓；最终决战到来之前的风雨欲来的紧迫感营造的很优秀，但是最终的杀人动机极为狗血。&emsp;&emsp;作者在主线情节的中间还穿插着一些支线情节，这些段落插曲一方面丰满了人物，另一方面也促进了情节的推动，每一个小故事或多或少的提供了一点线索。经纬度和环形密码还是比较有趣的。&emsp;&emsp;印象最深的还是男女主角对于工作的高度责任心。两个完全不相关的职业以及思考方式，在推理判断过程中的成长，从开始的互不理解到互相欣赏，在推理之余增加了温情。&emsp;&emsp;可能是因为之前看的东野的小说都太过经典和优秀（白夜行，解忧杂货铺等），所以对这本书阅读体验并不如期待。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
</search>
