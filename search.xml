<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode611.Valid Triangle Number(Medium)]]></title>
    <url>%2F2018%2F01%2F31%2Fleetcode611%2F</url>
    <content type="text"><![CDATA[问题描述 Given an array consists of non-negative integers, your task is to count the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.Example 1:Input: [2,2,3,4]Output: 3Explanation:Valid combinations are:2,3,4 (using the first 2)2,3,4 (using the second 2)2,2,3Note: The length of the given array won’t exceed 1000. The integers in the given array are in the range of [0, 1000]. 解题思路 暴力解法(O(n^3)) 排序+二分搜索(O(n^2 * lg(n)))根据三角形性质，两边之和大于第三边，排序后三位数字只需判定前两个数字之和大于第三个数字即可。所以在确定前两个数字后，第三个数字范围使用二分搜索即可得出。 进一步优化(O(n^2))与第二种方法不同的是使用双指针法，从后往前遍历，枚举最大的数，然后利用双指针left和right寻找到符合三角形条件的长度的两条边。因为若是left和right两条边与枚举的数能满足三角形条件，则这两个数中间的数和right以及枚举的数均能组成三角形。 代码展示 暴力解法(O(n^3)) 12345678910111213141516171819202122class Solution &#123;public: int triangleNumber(vector&lt;int&gt;&amp; nums) &#123; int count = 0; int size = nums.size(); for (int i = 0; i &lt; size-2; i++) for (int j = i+1; j &lt; size-1; j++) for (int k = j+1; k &lt; size; k++) if(isTriangle(nums[i], nums[j], nums[k])) count++; return count; &#125; bool isTriangle(int a, int b, int c)&#123; if (a+b &gt; c &amp;&amp; a+c &gt; b &amp;&amp; b+c &gt; a) return true; else return false; &#125;&#125;; 排序+二分搜索(O(n^2 * lg(n))) 123456789101112131415161718192021222324class Solution &#123;public: int triangleNumber(vector&lt;int&gt;&amp; nums) &#123; int count = 0; int size = nums.size(); sort(nums.begin(), nums.end()); for (int i = 0; i &lt; size; i++)&#123; for (int j = i+1; j &lt; size; j++)&#123; int sum = nums[i] + nums[j]; int left = j+1, right = size; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(nums[mid] &lt; sum) left = mid + 1; else right = mid; &#125; count += right - 1 - j; &#125; &#125; return count; &#125; &#125;; 进一步优化(O(n^2)) 1234567891011121314151617181920class Solution &#123;public: int triangleNumber(vector&lt;int&gt;&amp; nums) &#123; int count = 0; int size = nums.size(); sort(nums.begin(), nums.end()); for (int i = size - 1; i &gt;= 2; --i)&#123; int left = 0, right = i - 1; while (left &lt; right)&#123; if (nums[left] + nums[right] &gt; nums[i]) &#123; count += right - left; --right; &#125; else ++left; &#125; &#125; return count; &#125; &#125;; 参考]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode458.Poor Pigs(Easy)]]></title>
    <url>%2F2018%2F01%2F31%2Fleetcode458%2F</url>
    <content type="text"><![CDATA[问题描述 There are 1000 buckets, one and only one of them contains poison, the rest are filled with water. They all look the same. If a pig drinks that poison it will die within 15 minutes. What is the minimum amount of pigs you need to figure out which bucket contains the poison within one hour.Answer this question, and write an algorithm for the follow-up general case. Follow-up:If there are n buckets and a pig drinking poison will die within m minutes, how many pigs (x) you need to figure out the “poison” bucket within p minutes? There is exact one bucket with poison. 解题思路 先看一只猪再一个小时内最多能验多少桶？一次喝一个桶中的水，15分钟后再喝第二个桶的，一个小时可以喝60/15 = 4次，最后一个桶是否有毒可通过排除法确定是否有毒。所以一只猪仔一个小时内可以验证5个桶。 两只猪的时候呢？利用二维的思想，两只猪可分为两个维度分别喝水判定，根据两只猪的死亡时间可以判定出有毒的桶。也就是猪A/B每15分钟试喝一行/一列的所有五桶水。因此两只猪在一个小时内可以验证25个桶。 N只的时候后利用多维思想可以类推得出。 上面思路可以很简单的推广到一般情况。 代码展示(C++)1234567891011class Solution &#123;public: int poorPigs(int buckets, int minutesToDie, int minutesToTest) &#123; int dimension = minutesToTest / minutesToDie + 1; int ans = 0; while(pow(dimension, ans) &lt; buckets) ans++; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode31.Next Permutation(Medium)]]></title>
    <url>%2F2018%2F01%2F31%2Fleetcode%2031%20Next%20Permutation%2F</url>
    <content type="text"><![CDATA[问题描述 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place, do not allocate extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解题思路&emsp;&emsp;首先需要了解一下全排列及其对应字典序。 对于该题，其目的在于求给定排列的下一个全排列，如果是最后一个的话就返回第一个全排列：(1, 2, 3)-&gt;(1, 3, 2)、(1, 2, 3, 5, 4)-&gt;(1, 2, 4, 3, 5)、(5, 1, 1)-&gt;(1, 1, 5) 使用例子来说明解题方式：(6, 5, 4, 8, 7, 5, 1)：从后往前遍历，找到非递增的数位，即4-&gt;(8, 7, 5, 1)，然后调换后面递增数列中比4大的最小的数，调换位置即5-&gt;(8, 7, 4, 1)，最后在对后面的数字重排序一下即可(1, 4, 7, 8)，最终结果(6, 5, 5, 1, 4, 7, 8) 代码展示(C++)1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); int flag = 0; int i = size - 1; while(i &gt; 0)&#123; if(nums[i] &gt; nums[i-1])&#123; flag = i-1; break; &#125; i--; &#125; if (flag == 0 &amp;&amp; i == 0)&#123; sort(nums.begin(), nums.end()); return; &#125; int temp = flag + 1; for (int j = temp + 1; j &lt; size; j++)&#123; if (nums[j] &gt; nums[flag] &amp;&amp; nums[j] &lt; nums[temp]) temp = j; &#125; swap (nums[flag], nums[temp]); sort(nums.begin()+flag + 1, nums.end()); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让子弹飞一会儿]]></title>
    <url>%2F2018%2F01%2F20%2F%E8%AE%A9%E5%AD%90%E5%BC%B9%E9%A3%9E%E4%B8%80%E4%BC%9A%E5%84%BF%2F</url>
    <content type="text"><![CDATA[你说是钱对我重要，还是你对我重要你和钱对我都不重要，没有你，对我很重要 &emsp;&emsp;虽然这只是我看的姜文的第二部电影，但是在我心中已经可以把他和王小波一样捧到天上去了。前面一部看的是《鬼子来了》，尽管很多人说国民的劣根性，但是我还是为我民族的善良淳朴落泪。 &emsp;&emsp;因为涉及一些政治因素，《鬼子来了》被禁；《太阳照常升起》又因为一些晦涩难懂的隐喻而票房不佳。影评人或者观众或多或少总会有些怀疑姜文的导演能力，这些不认同的声音在他的心里挥之不去。所以这部片子他做出了一些改变，在我看来，一方面既能表达他心中想要表现的观点和情感，另一方便也是为了破除格局获得认同，按其电影里的话来说就是“站着也把钱赚了”(张和冯的电影大多向资本妥协)。从最后的票房结果和影片后续的评论看来，他也确实做到了。 &emsp;&emsp;关于人物关于情节不想多说，人各有见，豆瓣知乎也是有一大堆讨论的。想说的主要是自己对于这部片子和对于姜文的感受。 &emsp;&emsp;在影片中很多地方都能看到姜文的英雄主义情怀，比如松坡将军及小凤仙。不清楚姜文为何对民国时代情有独钟，或许是因为这个动荡的历史时期能有更多的材料能更好的抒发情绪吧。对于角色的名字也是颇为讲究，张牧之(张麻子)、武智冲、马邦德这几个带着或是隐喻或是恶趣味的名字也能让人为之一笑。 &emsp;&emsp;说下印象最深刻的几场戏： 小六子为了自证清白，不想说他中二，只是看到他最后死去的时候，心好像被什么抓住了似得，除了对这个有血性的少年的心疼之外，剩下的也只有对于一哄而散的看客和强权者及畏于强权者的愤怒。 三个影帝同台飙戏，据说是拍了好几十次才完成的，也难怪如此耐看，不管是镜头的转换还是台词对于人物的勾勒对于情节的推动都无可挑剔。有人说是因为姜文对葛优说剧组里有发哥，对发哥说剧组里有葛优才把这两人凑到了一起，且不论真假，能看到这三位出现在同一个大荧幕上就够开心了。 叹号之后的问号，两个简简单单的符号很容易的就表达了其对于革命的必要性以及革命之后的路要怎么走(抑或是对于革命后)的困惑。 “上海就是浦东，浦东就是上海”。 &emsp;&emsp;借用豆瓣上一个影评中的两句话作为结尾吧： 在其最纯粹的意义上，只要贫穷和等级制依然存在，革命就永无止息。然而对于大多数人而言，革命之后，应当是世俗生活的开始，而不是继续革命，更不是永远革命。 于是，一切血与火最终都淹没在湖光山色掩映中的那首《送别》之中，火车开向七十年后改革开放的浦东，尾随的骑士沿着铁轨独行成一个孤绝的背影。这一切，像一个开始，又像一个结尾，更像是一个轮回。]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>让子弹飞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python作用域和命名空间示例]]></title>
    <url>%2F2018%2F01%2F15%2FPython%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;以下示例演示了如何引用不同作用域和命名空间，以及global和nonlocal如何影响变量绑定：12345678910111213141516171819def scope_test(): def do_local(): spam = "local spam" def do_nonlocal(): nonlocal spam spam = "nonlocal spam" def do_global(): global spam spam = "global spam" spam = "test spam" do_local() print("After local assignment:", spam) do_nonlocal() print("After nonlocal assignment:", spam) do_global() print("After global assignment:", spam)scope_test()print("In global scope:", spam) &emsp;&emsp;输出为：1234After local assignment: test spamAfter nonlocal assignment: nonlocal spamAfter global assignment: nonlocal spamIn global scope: global spam 注意：local赋值语句无法改变scope_test的spam绑定。nonlocal赋值语句改变了scope_test的spam绑定，并且global赋值语句从模块级改变了spam绑定。(global赋值语句之前对spam是没有预先绑定的)]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码风格]]></title>
    <url>%2F2018%2F01%2F10%2Fpython%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;对于python，PEP8引入了大多数项目遵循的风格指导。给出了一个高度可读，视觉友好的编码风格。下面是一些关键要点： 使用4空格缩进，而非TAB在小缩进(可以嵌套更深)和大缩进(更易读)之间，4空格是一个较好的折中。TAB引发了一些混乱，最好弃用。 折行以确保其不会超过79字符 这有助于小显示器用户阅读，也可以让大显示器能并排显示几个代码文件 使用空行分隔函数和类，以及函数中的大块代码 可能的话，注释独占一行 使用文档字符串 把空格放到操作符两边，以及逗号后边，但是括号里侧不加空格：a = f(1, 2) + g(3, 4) 同一函数和类命名 推荐类名用驼峰命名函数和方法名用小写_和_下划线 。总是用self作为方法的第一个参数 不要使用花哨的编码，如果你的代码的目的是要在国际化环境。Python的默认情况下，UTF-8，甚至普通的ASCII总是工作的最好 同样，也不要使用非ASCII字符的标识符，除非是不同语种的会阅读或者维护代码]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win必备工具]]></title>
    <url>%2F2018%2F01%2F10%2Fwin%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[1.Sublime Text&emsp;&emsp;下载地址：Sublime Text&emsp;&emsp;参考博客 最爱的一款文本编辑器，可安装多种插件 2.Cmder&emsp;&emsp;下载地址：Cmder&emsp;&emsp;参考博客 比windows原生cmd好出了天际，支持PowerShell，完全版本自带git。 3.Launchy&emsp;&emsp;下载地址：Launchy 免费开源快速启动软件 安装简易，按alt+space启动 多种皮肤可供选用 提供了一些插件扩展 还可以自定义目录及文件 4.MacType&emsp;&emsp;下载地址：Mactype 改善Windows字体渲染 热替换系统默认字体 &emsp;&emsp;MacType自带了多种配置文件，根据需要选择即可。]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective C++(第三版)读书笔记]]></title>
    <url>%2F2018%2F01%2F10%2FEffective%20C%2B%2B(%E7%AC%AC%E4%B8%89%E7%89%88)%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 让自己习惯C++(Accustoming Yourself to C++)条款01：视C++为一个语言联邦(View C++ as a federation of languages) C。C++以C为基础。区块(blocks)、语句(statements)、预处理器(preprocessor)、内置数据类型(built-in data types)、数组(arrays)、指针(pointers)。 Object-Oriented C++。classes(包括构造函数和析构函数)，封装(encapsulation)、继承(inheritance)、多态(polymorphism)、virtual函数(动态绑定)…… Template C++。C++的泛型编程(generic programing)部分。 STL。STL是个template程序库。它对容器(containers)、迭代器(iterators)、算法(algorithms)以及函数对象的规约有极佳的紧密配合与协调。 &emsp;&emsp;记住这四个次语言，每个次语言都有自己的规约(视情况而定)。 条款02. 尽量以const，enum，inline替换#define(Prefer consts, enums, and inlines to #defines) 对于单纯常量，最好以const对象或enums替换#define。 对于形似函数的宏(macros)，最好改用inline函数替换#defines。 条款03. 尽可能使用const(Use const whenever possible)&emsp;&emsp;const允许你指定一个语义约束(指定一个“不该被改动”的对象)，而编译器会强制实施这项约束。将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。1234567// 如果const出现在星号左边，表示被指物是常量；// 如果const出现在星号右边，表示指针本身是常量；char greeting[] = "Hello";char* p = greeting; // non-const pointer, non-const dataconst char* p = greeting; // non-const pointer, const datachar* const p = greeting; // const pointer, non-const dataconst char* const p = greeting; // const pointer, const data &emsp;&emsp;如果希望STL迭代器所指的东西不可被改动(即希望STL模拟一个const T*指针)，需要的是const_iterator:12345678std::vector&lt;int&gt; vec;...const std::vector&lt;int&gt;::iterator iter = vec.begin(); // iter的作用像个T* const*iter = 10; // 没问题，改变iter所指物++iter; // 错误！iter是constconst std::vector&lt;int&gt;::const_iterator citer = vec.begin(); // citer的作用像个const T**citer = 10; // 错误！*citer是const++citer; // 没问题，改变cIter const成员函数&emsp;&emsp;将const实施于成员函数的目的，是为了确认该成员函数可作用于const对象身上。重要原因有两点: 使得class接口比较容易被理解。因为，得知哪个函数可以改动对象内容而哪个不行，是很重要的。 使得“操作const对象”成为可能。 条款04. 确定对象被使用前已先被初始化(Make sure that objects are initialized before they are used) 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初值列(member initialization list)，而不要在构造函数本体内使用赋值操作(assignment)。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 2.构造/析构/赋值运算(Constructors, Destructors, and Assignment Operators)条款05. 了解C++默默编写并调用哪些函数(Know what functions C++ silently writes and calls) 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符、以及析构函数。 &emsp;&emsp;如果你写下：1class Empty &#123; &#125;; &emsp;&emsp;实际上是：12345678class Empty &#123;public: Empty() &#123;...&#125; // default构造函数 Empty(const Empty&amp; rhs) &#123;...&#125; // copy构造函数 ~Empty() &#123;...&#125; // 析构函数 Empty&amp; operator=(const Empty&amp; rhs) &#123;...&#125;// copy assignment操作符&#125;; &emsp;&emsp;如果本身声明了构造函数，编译器就不再为它创建default构造函数。 条款06. 若不想使用编译器自动生成的函数，就该明确拒绝(Explicitly disallow the use of compiler-generated functions you do not want.) 为驳回编译器自动(暗自)提供的机能，可将相应的成员函数声明为private并且不予实现。使用Uncopyable这样的base class也是一种做法。 1234567891011121314151617181920212223// Solution 1：class HomeForSale &#123;public: ...private: ... HomeForSale(const HomeForSale&amp;); // 只有声明 HomeForSale&amp; operator=(const HomeForSale&amp;); &#125;;// Solution 2:class Uncopyable &#123; // 允许derived对象构造和析构protected: Uncopyable() &#123;&#125; ~Uncopyable() &#123;&#125;private: Uncopyable(const Uncopyable&amp;)； // 但阻止copying Uncopyable&amp; operator=(const Uncopyable&amp;);&#125;;// 为求阻止HomeForSale对象被拷贝，唯一需要做的是继承Uncopyable:class HomeForSale: private Uncopyable &#123; // class 不在声明 ... // copy构造函数或&#125;; // copy assign 操作符 条款07. 为多态基类声明virtual析构函数(Declare destructors virtual in polymorphic base classes.)&emsp;&emsp;(多态性质情况下)为防止出现“局部销毁”对象，造成资源泄露等结果，需要给base class一个virtual析构函数。伺候删除derived class对象就会销毁整个对象，包括derived class成分：123456789class TimeKeeper &#123;public: TimeKeeper(); virtual ~TimeKeeper(); ...&#125;;TimeKeeper* ptk = getTimeKeeper();...delete ptk; // 现在，行为正确 如果class不含virtual函数，通常表示它并不意图被用做一个base class。许多人的心得是：只有当class内含至少一个virtual函数，才为它声明virtual析构函数。 条款08. 别让异常逃离析构函数(Prevent exceptions from leaving destructors) 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下他们(不传播)或结束程序。 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数(而非在析构函数中)执行该操作。 条款09. 绝不在构造和析构过程中调用virtual函数(Never call virtual functions during construction or destruction.) 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class(比起当前执行构造函数和析构函数的那层)。 条款10. 令operator= 返回一个reference to *this(Have assigment operators return a reference to *this.)123456789class Widget &#123;public: Widget&amp; operator+=(const Widget&amp; rhs) &#123; ... return* this; &#125; ...&#125;; &emsp;&emsp;注意，这只是个协议，并无强制性。 条款11. 在operator= 中处理“自我赋值”(Handle assignment to self in operator=.) 确保当对象自我赋值时operator= 有良好行为。其中技术包括比较“来源对象”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap。 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 123456789101112131415161718192021222324252627282930class Bitmap &#123;...&#125;;// 1.比较(证同测试)Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; if (this == &amp;rhs) return *this; // 证同测试 // 如果是自我赋值，就不做任何事 delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;// 2.语句顺序Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Bitmap* pOrig = pb; // 记住原先的pb pb = new Bitmap(*rhs.pb); // 令pb指向*pb的一个复件(副本) delete pOrig; // 删除原先的pb return *this;&#125;// 3.copy-and-swapclass Widget &#123; ... void swap(Widget&amp; rhs); //交换*this和rhs的数据; ...&#125;;Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123; Widget temp(rhs); // 将*this数据和上述复件的数据交换 return *this;&#125; 条款12. 复制对象时勿忘其每一个成分(Copy all parts of an object.)&emsp;&emsp;设计良好之面向对象系统(OO-system)会将对象的内部封装起来，只留两个函数负责对象拷贝(复制)，就是copy构造函数和copy assignment操作符(即为copying函数)。&emsp;&emsp;任何时候只要你承担起“为derived class撰写copying函数”的重责大任，必须很小心地也复制器base class成分。那些成分往往是private，所以无法直接访问它们，你应该让derived class的copying函数调用相应的base class函数。 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”。 不要尝试某个copying函数实现另一个copying函数。应该将共同机能放进第三个函数中(如init函数)，并由两个copying函数共同调用。 3.资源管理(Resource Management) 内存只是必须管理的众多资源之一，其他常见的资源还包括文件描述器(file descriptors)、互斥锁(mutex locks)、图形界面中的字型和笔刷、数据库连接、以及网络sockets。 条款13. 以对象管理资源(Use objects to manage resources.)123456void f()&#123; std::auto_ptr&lt;Investment&gt; pInv(createInvestment( )); // 调用factory函数 ... // 一如既往地使用pInv&#125; // 经由auto_ptr的析构甘薯自动删除pInv &emsp;&emsp;这个简单例子示范了“以对象管理资源”的两个关键想法： 获得资源后立刻放进管理对象内。以上代码中createInvestment返回的资源被当作其管理者auto_ptr的初值。实际上“以对象管理资源”的观念常备称为“资源取得时机便是初始化时机”(Resource Acquisition Is Initialization;RAII)。 管理对象运用析构函数确保资源被释放。 &emsp;&emsp;注意auto_ptrs有一个性质：若通过copy构造函数或copy assignment操作符复制它们，它们会变成null，而复制所得的指针将取得资源的唯一拥有权！123std::auto_ptr&lt;Investment&gt; pInv1(createInvestment( )); // pInv1指向createInvestment返回物std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // 现在pInv2指向对象，pInv1被设为nullpInv1 = pInv2; // pInv2被设为null &emsp;&emsp;使用tr1::shared_ptrs比auto_ptrs的复制正常一些。 为防止资源泄露，清使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源。 两个常备使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它(被复制物)指向null。 条款14. 在资源管理类中小心copying行为(Think carefully behavior in resource-managing classes.)&emsp;&emsp;RAII守则“资源在构造期间获得，在析构期间释放”。 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。 普遍而常见的RAII class copying行为是：抑制copying、施行引用计数法(reference counting)。不过其他行为也都可能被实现。 条款15. 在资源管理类中提供对原始资源的访问(Provide access to raw resources in resource-managing classes.) APIs往往要求访问原始资源(raw resources)，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。 对原始资源的访问可能经由显式转换或者隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。 条款16. 成对使用new和delete时要采取相同形式(Use the same form in corresponding uses of new and delete) 如果你在new表达式中使用[]，必须在相应的delete表达式中也使用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 条款17. 以独立语句将newed对象置入智能指针(Store newed objects in smart pointers in standalone statements.)12std::tr1::shared_ptr&lt;Widget&gt; pw(new Widget); // 在单独语句内以只能指针存储newed所得对象processWidget(pw, priority()); // 这个调用动作决不至于造成泄露 以独立语句将newed对象存储于(置入)智能指针中。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 4. 设计与声明(Designs and Declarations) 让接口容易被正确使用，不容易被误用(正确性、高效性、封装性、维护性、延展性、以及协议的一致性)。 条款18. 让接口容易被正确使用，不易被误用(Make interfaces easy to use correctly and hard to use incorrectly.) 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。 “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。 “阻止误用”的方法包括建立新类型、限制类型上的操作、束缚对象值、以及消除客户的资源管理责任。 tr1::shared_ptr支持定制型删除器(custom deleter)。这可防范DLL问题，可被用来自动解除互斥锁等等。 条款19. 设计class犹如设计type(Treat class design as type design) 新type的对象应该如何被创建和销毁？ 对象的初始化和对象的赋值该有什么样的差别？ 新type的对象如果被passed by value，意味着什么？ 什么是新type的“合法值”？ 你的新type需要配合某个继承图系(inheritance graph)吗？ 你的新type需要什么样的转换？ 什么样的操作符和函数对此新type而言是合理的？ 什么样的标准函数应该驳回？ 谁该取用新type的成员？ 什么是新type的“未声明接口”(undeclared interface)？ 你的新type有多么一般化？ 你真的需要一个新type吗？ 条款20. 宁以pass-by-reference-to-const替换pass-by-value&emsp;&emsp;缺省情况下C++以by value方式传递对象至函数。 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题(slicing problem)。 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。 条款21. 必须返回对象时，别妄想返回其reference(Don’t try to return a reference when you must return an object.)&emsp;&emsp;一个“必须返回新对象”的函数的正确写法是让其返回一个新对象。1234inline const Rational operator * (const Rational&amp; lhs, const Rational&amp; rhs)&#123; return Rational(lhs.n * rhs.n, lhs.d * rhs.d);&#125; 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。 条款22. 将成员变量声明为private(Declare data members private.) 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。 protected并不比public更具封装性。 条款23. 宁以non-member、non-friend替换member函数 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性(packaging flexibility)和机能扩充性。 条款24. 若所有参数皆需类型转换，请为此采用non-member函数(Declare non-member functions when type conversions should apply to all parameters.) 如果你需要为某个函数的所有参数(包括被this指针所指的那个隐喻参数)进行类型转换，那么这个函数必须是non-member。 条款25. 考虑写出一个不抛出异常的swap函数(Consider support for a non-throwing swap.) 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。 如果你提供一个member swap，特该提供一个non-member swap用来调用前者。对于classes(而非templates)，也请特化std::swap。 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”。 为“用户定义类型”进行std templates全特化是最好的，但千万不要尝试在std内加入某些对std而言全新的东西。 5. 实现(Implementations)&emsp;&emsp;太快定义变量可能造成效率上的拖延；过渡使用转型(casts)可能导致代码变慢又难维护，又找来微妙难解的错误；返回对象“内部数据之号码牌(handles)”可能会破坏封装并留给客户虚吊号码牌(danling handles)；未考虑异常带来的冲击则可能导致资源泄露和数据败坏；过渡热心地inlining可能引起代码膨胀；过渡耦合(coupling)则可能导致让人不满意的冗长建置时间(build times)。 条款26. 尽可能延后变量定义式的出现时间(Postpone variable definitions as long as possible.)&emsp;&emsp;不只应该延后变量的定义，直到非得使用该变量的前一刻为止，甚至应该尝试延后这份定义直到能够给它初始实参为止。如果这样，不仅能够避免构造(和析构)非必要对象，还可以避免无意义的default构造行为。 条款27. 尽量少做转型动作(Minimize casting.)&emsp;&emsp;C++提供了四种新式转型(new-style/C++-style casts)123456789// 旧式 old-style casts(T)expression //将expression转型为TT(expression) //~// new-styleconst_cast&lt;T&gt;( expression )dynamic_cast&lt;T&gt;( expression )reinterpret_cast&lt;T&gt;( expression )static_cast&lt;T&gt;( expression ) &emsp;&emsp;各有不同的目的： const_cast通常被用来将对象的常量性移除(cast away the constness)。也是唯一有此能力的 C++-style转型操作符。 dynamic_cast主要用来执行“安全向下转型”(safe downcasting)，也就是用来决定某对象是否归属继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。 reinterpret_cast意图执行低级转型，实际动作及结果可能取决于编译器，也就是说它不可移植。 static_cast用来强迫隐式转换(implicit conversions)，例如将non-const对象转为const对象等。它也可以用来执行上述多种转换的反向转换，但无法将const转为non-const。 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码内。 宁可使用C++-style(新式)转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的德州的执掌。 条款28. 避免返回handles指向对象内部成分(Avoid returning “handles” to object internals.) 成员变量的封装性最多只能等于“返回其reference”的函数的访问级别。 如果const成员函数传出一个reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据。&emsp;&emsp;如果返回的是指针或迭代器，相同的情况还是发生，原因也相同。References、指针和迭代器都是所谓的handles 避免返回handles(包括references、指针、迭代器)指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”(dangling handles)的可能性降至最低。 条款29. 为“异常安全”而努力是值得的(Strive for exception-safe code.)&emsp;&emsp;当异常被抛出时，带有异常安全性的函数会： 不泄露任何资源 不允许数据败坏 &emsp;&emsp;异常安全函数(Exception-safe functions)提供以下三个保证之一： 基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，任何对象都处于一种内部前后一致的状态(例如所有的class约束条件都继续获得满足)。 强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需有这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会回复到“调用函数之前”的状态。 不抛掷(nothrow)保证：承诺绝不抛出异常，因为它们总能够完成它们原先承诺的功能。作用于内置类型(例如ints，指针等等)身上的所有操作都提供nothrow保证。 异常安全函数(Exception-safe functions)即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型。 “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证中的最弱者”。 条款30. 透彻了解inlining的里里外外(Understand the ins and outs of inlining.)&emsp;&emsp;80-20经验法则：平均而言一个程序往往将80%的执行时间花费在20%的代码上。 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级(binary upgradability)更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化。 不要只因为function templates出现在头文件，就将它们声明为inline。 条款31. 将文件间的编译依存关系降至最低(Minimize compilation dependencies between files.)&emsp;&emsp;编译依存性最小化的本质：显示中让头文件尽可能自我满足，万一做不到，则让它与其他文件内的声明式(而非定义式)相依： 如果使用object references 或 object pointers可以完成任务，就不要使用objects。 如果能够，尽量以class声明式替换class定义式。 为声明式和定义式提供不同的头文件。 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes。 程序库头文件应该以“完全且仅有声明式”(full and declaration-only forms)的形式存在。这种做法不论是否涉及templates都适用。 6 继承与面向对象设计(Inheritance and Object-Oriented Design.)条款32. 确定你的public继承塑模出is-a关系(Make sure public inheritance models “is-a.”) “public继承”以为is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。 条款33. 避免遮掩继承而来的名称(Avoid hiding inherited names.) derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此。 为了让被遮掩的名称再见天日，可使用using声明式或转交函数(forwarding functions)。 条款34. 区分接口继承和实现继承(Differentiate between inheritance of interface and inheritance of implementation.)&emsp;&emsp;pure virtual函数有两个最突出的特性：它们必须被任何“继承了它们”的具象class重新声明，而且它们在抽象class中通常没有定义。而impure virtual函数会提供一份实现代码，derived classes可能覆写(override)它。一个non-virtual成员函数所表现的不变性(invariant)凌驾其特异性(specialization)，因为它表示不论derived class变得多么特异化，它的行为都不可以改变，也绝不该在derived class中被重新定义。 成员函数的接口总是会被继承。 声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。 声明简朴的(非纯)impure virtual函数的目的，是让derived classes继承该函数的接口和缺省实现。 声明non-virtual函数的目的是为了令derived classes继承函数的接口及一份强制性实现。 条款35. 考虑virtual函数以外的其他选择(Consider alternatives to virtual functions.) 使用non-virtual interface(NVI)手法，那是Template Method设计模式的一种特殊形式。它以public non-virtual成员函数包裹较低访问性(private或protected)的virtual函数。 将virtual函数替换为“函数指针成员变量”，这是Strategy设计模式的一种分解表现形式。 以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物搭配一个兼容于需求的签名式。这也是Strategy设计模式的眸子形式。 将基础体系内的virtual函数替换为另一个继承体系内的virtual函数。这是Strategy设计模式的传统实现手法。 条款36. 绝不重新定义继承而来的non-virtual函数(Never redefine an inherited non-virtual function.)&emsp;&emsp;non-virtual函数实静态绑定的，如pB被声明为一个pointer-to-B，通过pB调用的non-virtual函数永远是B所定义的版本，即使pB指向一个类型为“B派生之class”的对象；而virtual函数却是可以动态绑定的。 条款37. 绝不重新定义继承而来的缺省参数值(Never redefine a function’s inherited default parameter value.)&emsp;&emsp;virtual函数系动态绑定，而缺省参数值却是静态绑定。意思是你可能会在“调用一个定义于derived class内的virtual函数”的同时，却使用base class为它所指定的缺省参数值。 静态绑定：又名前期绑定(early binding) 静态类型(static type)：在程序中被声明时所采用的类型。 动态绑定：又名后期绑定(late binding) 动态类型(dynamic type):指的是“目前所指对象的类型”，也就是说，没动态类型可以表现出一个对象将会有什么行为。。 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数————你唯一应该覆写的东西————却是动态绑定。 条款38. 通过复合塑模出has-a或“根据某物实现出”(Model “has-a” or “is-implemented-in-terms-of” through composition.) 复合(composition)的意义和public继承完全不同。 在应用域(application domain)，复合意味has-a(有一个)。在实现域(implementation domain)，复合意味is-implemented-in-terms-of(根据某物实现出)。 条款39. 明智而审慎地使用private继承(Use private inheritance judiciously.) 如果classes之间的继承关系是private，编译器不会自动将一个derived class对象(例如Student)转换为一个base class对象(例如Person)。这和public继承不同。 由private base class继承而来的所有成员，在derived class中都会变成private属性，纵使它们在base class中原本是protected或public属性。 &emsp;&emsp;private继承意味着只有实现部分被继承，接口部分略去。 private继承意味is-implemented-in-terms of(根据某物实现出)。它通常比复合(composition)的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的。 和复合(composition)不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序库开发者而言，可能很重要。 条款40. 明智而审慎地使用多重继承(Use multiple inheritance judiciously.) 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要。 virtual继承会增加大小、速度、初始化(及赋值)复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况。 多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。 7. 模板与泛型编程(Templates and Generic Programming.)(粗略阅读)条款41. 了解隐式接口和编译期多态(Understand implicit interfaces and compile-time polymorphism.) classes 和 templates都支持接口(interfaces)和多态(polymorphism)。 对classes而言接口是显式的(explicit)，以函数签名为中心。多态则是通过vvirtual函数发生于运行期。 对templa参数而言，接口是隐式的(implicit)，奠基于有效表达式。多态则是通过template具现化和函数重载解析(function overloading resolution)发生于编译期。 条款42. 了解typename的双重意义(Understand the two meanings of typename.) 声明template参数时，前缀关键字class和typename可互换。 请使用关键字typename标识嵌套从属类型名称；但不得在base class lists(基类列)或member initialization list(成员初值列)内以它作为base class修饰符。 条款43. 学习处理模板化基类内的名称(Know how to access names in templatized base classes.) 可在derived class templates内通过“this-&gt;”指涉base class templates内的成员名称，或藉由一个明白写出的“base class资格修饰符”完成。 条款44. 将与参数无关的代码抽离templates(Factor parameter-independent code out of templates.) Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系。 因非类型模板参数(non-type template parameters)而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数。 因类型参数(type parameters)而造成的代码膨胀，往往可降低，做法是让带有完全相同的二进制表述(binary representations)的具现类型(instantiation types)共享实现码。 条款45. 运用成员函数模板接受所有兼容类型(Use member function templates accept “all compatible types.”) 请使用member function templates(成员函数模板)生成“可接受所有兼容类型”的函数。 如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。 条款46. 需要声明类型转换时轻微模板定义非成员函数(Define non-member functions inside templates when type conversions are desired.) 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。 条款47. 请使用traits classes表现类型信息(Use traits classes for information about types.) Traits classes使得“类型相关信息”在编译器可用。它们以templates和“templates特化”完成实现。 整合重载技术(overloading)后，traits classes有可能在编译器对类型执行if…else测试。 条款48. 认识template元编程(Be aware of template metaprogramming.) Template metaprogramming(TMP，模板元编程)可将工作由运行期移往编译器，因而得以实现早期错误侦测和更高的执行效率。 TMP可被用来生成“基于政策选择组合”(based on combinations of policy choices)的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 8. 定制new和delete(CUstomizing new and delete)(粗略阅读)条款49. 了解new-handler的行为(Understand the behavior of the new-handler.) set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用。 Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。 条款50. 了解new和delete的合理替换时机(Understand when it makes sense to replace new and delete.) 有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。 条款51. 编写new和delete时需固守常规(Adhere to convention when writing new and delete.) operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的(错误)申请”。 条款52.写了placement new也要写placement delete(Write placement delete if you write placement new.) 当你写一个placement operator new，请确定也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄漏。 当你声明placement new 和placement delete，请确定不要无意识(非故意)地遮掩了它们的正常版本。 9. 杂项讨论(Miscellany)条款53. 不要轻忽编译器的警告(Pay attention to compiler warnings.) 严肃对待编译器发出的警告信息。努力在你的编译器的最高(最严苛)警告级别下争取“无任何警告”的荣誉。 不要过度依赖编译器的报警能力，因为不同的编译器对待事物的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 条款54. 让自己熟悉包括TR1在内的标准程序库(Familiarize yourself with the standard library, including TR1.)&emsp;&emsp;C++98列入的C++标准程序库的主要成分： STL(Standard Template Library，标准模板库)，覆盖容器(containers如vector,string,map)、迭代器(iterator)、算法(algorithms如find，sort，transform)、函数对象(function objects如less，greater)、各种容器适配器(container adapters如stack，priority_queue)和函数对象适配器(function object adapters如mem_fun，not1)。Iostream，覆盖用户自定缓冲功能、国际化I/O，以及预先定义好的对象cin，cout，cerr和clog。国际化支持，包括多区域(multiple active locales)能力。像wchar_t(16bits/char)和wstring(wchar_ts组成的strings)等类型都对促进Unicode有所帮助，数值处理，包括复数模板(complex)和纯数值数组(valarray)。异常阶层体系(exception hierarchy)，包括base class exception及其derived classes logic_cerr和runtime_error，以及更深继承的各个classes。C89标准程序库。1989C标准程序库内的每个东西也都被覆盖于C++内。 &emsp;&emsp;TR1详细叙述了14个新组件(components，也就是程序库机能单位)，统统放在std命名空间内，更正确地说是在其嵌套命名空间tr1内。 智能指针(smart pointers) tr1::shared_ptr和tr1::weak_ptr。 tr1::function，此物得以表示任何callable entity(可调用物，也就是任何函数或函数对象)，只要其签名符合目标。 tr1::bind，它能够做STL绑定器(binders)bind1st和bind2nd所做的每一件事，而又更多。 Hash tables，用来实现sets，multisets，maps和multi-maps。 正则表达式(Regular expressions)，包括正则表达式为基础的字符串查找和替换，或是从某个匹配字符串到另一个匹配字符串的逐一迭代(iterator)等等。 Tuples(变量组)，这是标准程序库中的pair template的新一代制品。pair只能持有两个对象，tr1::tuple可持有任意个数的对象。 tr1::aray，本质上是个“STL化”数组，即一个支持成员函数如begin和end的数组。不过tr1::array的大小固定，并不适用动态内存。 tr1::mem_fn，这是个语气构造上与成员函数指针(member function pointers)一致的东西。 tr1::reference_wrapper，一个“让references的行为更像对象”的设施。它可以造成对象容器“犹如持有references”。 随机数(random number)生成工具，它大大超越了rand，那是C++继承自C标准程序库的一个函数。 数学特殊函数，包括Laguerre多项式、Bessel函数、完全椭圆积分(complete elliptic integrals)，以及更多数学函数。 C99兼容扩充。这是一大堆函数和模板，用来将许多新的C99程序库特性带进C++。 Type traits，一组traits classes，用于提供类型(types)的编译期信息。 tr1::result_of，这是个template，用来推到函数调用的返回类型。 C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库。 TR1添加了智能指针(如tr1::shared_ptr)、一般化函数指针(tr1::function)、hash-based容器、正则表达式(regular expressions)以及另外是个组件的支持。 TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是Boost。 条款55：让自己熟悉Boost(Familiarize yourself with Boost.)&emsp;&emsp;Boost程序库对付的主题非常繁多，区分数十个类目，包括(程序库抽样)： 字符串与文本处理，覆盖具备类型安全(safe-type)的printf-like格式化动作、正则表达式，以及语汇单元切割(tokenizing)和解析(parsing)。 容器，覆盖“接口与STL相似且大小固定”的数组、大小可变的bitsets以及多位数组。 函数对象和高级编程，覆盖若干倍用来作为TR1机能基础的程序库。 泛型编程(Generic programming)，覆盖一大组traits classes。 模板元编程(Template metaprogramming, TMP)，覆盖一个针对编译器assertions而写的程序库，以及Boost MPL程序库。 数学与数值(Math and numerics)，包括有理数、八元数和四元数(octonions and quaternions)、常见的公约数(divisor)和少见的多重运算、随机数。 正确性与测试(Correctness and testing)，覆盖用来将隐式模板接口形式化的程序库，以及针对“测试优先”编程形态而设计的措施。 数据结构，覆盖类型安全和unions以及tuple程序库。 语言间的支持(Inter-language support)，包括允许C++和Python之间的无缝互操作性(seamless interoperability)。 内存，覆盖Pool程序库，用来做出高效率而区块大小固定的分配器，以及多变化的智能指针，包括TR1智能指针。 杂项，包括CRC检验、日期和时间的处理、在文件系统上来回移动等等。 Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深具影响力的角色。 Boost提供许多TR1组件实现品，以及其他许多程序库。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-Next配置]]></title>
    <url>%2F2018%2F01%2F05%2FHexo-Next%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. 添加[关于][标签]等页面 hexo new page about hexo new page tags 2.头像设置&emsp;&emsp;修改站点配置文件，修改avatar,值设置成头像的链接或者地址1234# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gifavatar: /images/avatar.jpg 3. 圆形头像（添加旋转）&emsp;&emsp;Next主题默认不支持，修改source/css/_common/components/sidebar/sidebar-author.styl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ -webkit-animation: play 2s ease-out 1s 1; -moz-animation: play 2s ease-out 1s 1; animation: play 2s ease-out 1s 1; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125;.site-author-name &#123; margin: $site-author-name-margin; text-align: $site-author-name-align; color: $site-author-name-color; font-weight: $site-author-name-weight;&#125;.site-description &#123; margin-top: $site-description-margin-top; text-align: $site-description-align; font-size: $site-description-font-size; color: $site-description-color;&#125; 4.删除底部HEXO主题和主题&emsp;&emsp;修改\themes\next\layout_partials\footer.swig文件，删除:12345678910&lt;div class=&quot;powered-by&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.powered&apos;, &apos;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://hexo.io&quot;&gt;Hexo&lt;/a&gt;&apos;) &#125;&#125;&#123;##&#125;&lt;/div&gt;&lt;div class=&quot;theme-info&quot;&gt;&#123;# #&#125;&#123;&#123; __(&apos;footer.theme&apos;) &#125;&#125; &amp;mdash; &#123;# #&#125;&lt;a class=&quot;theme-link&quot; target=&quot;_blank&quot; href=&quot;https://github.com/iissnan/hexo-theme-next&quot;&gt;&#123;# #&#125;NexT.&#123;&#123; theme.scheme &#125;&#125;&#123;# #&#125;&lt;/a&gt;&#123;% if theme.footer.theme.version %&#125; v&#123;&#123; theme.version &#125;&#125;&#123;% endif %&#125;&#123;##&#125;&lt;/div&gt; 5.网站底部添加访问量&emsp;&emsp;打开\themes\next\layout_partials\footer.swig文件，在copyright前加上：1&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &emsp;&emsp;然后再合适的位置添加显示统计的代码:12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; &emsp;&emsp;这里有两种计算方式的统计代码: pv方式，单个用户连续点击n篇文章，记录n次访问量 uv方式，单个用户连续点击n篇文章，只记录1次访客量 6. 网站底部字数统计&emsp;&emsp;切换到根目录下，然后运行如下代码1$ npm install hexo-wordcount --save &emsp;&emsp;然后在/themes/next/layout/_partials/footer.swig恰当位置添加：1234&lt;div class=&quot;theme-info&quot;&gt; &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt; &lt;span class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt; 7.设置网站的图标Favicon&emsp;&emsp;在EasyIcon中找到适当的比例的ico图标，或者从别的网站下载或制作，并将名称修改为favicon.ico，然后将图标放在/themes/next/source/images，并修改主题配置文件：12345678favicon: small: /images/favicon.ico #favicon-16x16-next.png medium: /images/favicon.ico #favicon-32x32-next.png apple_touch_icon: /images/favicon.ico #apple-touch-icon-next.png safari_pinned_tab: /images/favicon.ico 8.实现统计功能&emsp;&emsp;在根目录下安装hexo-wordcount，运行1$ npm install hexo-wordcount --save &emsp;&emsp;然后在主题配置文件中，配置如下：1234post_wordcount: item_text: true wordcount: true min2read: true 9.添加顶部加载条&emsp;&emsp;修改主题配置文件，将pace: false改为pace: true即可，里面还内置了很多样式，可直接更换。 10.设置阅读全文 在文章中使用手动进行截断(推荐): 1&lt;!-- more --&gt; 在文章的front-matter中添加description，并提供文章摘录 自动形成摘要，在主题配置文件中添加：123auto_excerpt:enable: truelength: 150 11.文章打赏&emsp;&emsp;在文章开头添加reward: true，并修改主题配置页面：1234# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechatpay.jpgalipay: /images/alipay.jpg 12.返回顶部组件增加百分比&emsp;&emsp;在主题配置文件中修改scrollpercent 13.博文置顶&emsp;&emsp;将文件node_modules/hexo-generator-index/lib/generator.js中代码修改为12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; &emsp;&emsp;在文章中添加top值，数值越大，文章越靠前。 14.修改打赏字体不闪动&emsp;&emsp;修改文件123456789101112```/* 注释文字闪动函数 #wechat:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125; #alipay:hover p&#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 15.添加评论功能（liveRe 来必力）&emsp;&emsp;注册来必力，获取liver_uid，编辑主题配置文件，编辑livere_uid即可。 16.添加阅读次数&emsp;&emsp;注册LeanCloud 首先在应用创建一个应用，名字随意 然后在存储-&gt;数据中创建class，取名为Counter 在设置-&gt;应用Key中取得APP ID和APP Key 回到设置，选择安全中心，在Web安全域名中添加博客地址 &emsp;&emsp;修改主题配置文件:1234leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key 17. 修改文章底部带#标签&emsp;&emsp;修改模板/themes/next/layout/_macro/post.swig，搜索rel=”tag”&gt;#，将 # 换成1&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 18. 修改文章内链接文本样式&emsp;&emsp;将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。找到文件themes\next\source\css_custom\custom.styl，添加如下 css 样式：12345678.post-body p a &#123; color: #0593d3; border-bottom: none; &amp;:hover &#123; color: #0477ab; text-decoration: underline; &#125;&#125; 19.搜索功能&emsp;&emsp;安装hexo-generator-searchdb，在站点根目录下执行1$ npm install hexo-generator-searchdb --save &emsp;&emsp;编辑站点配置文件，新增以下内容到任意位置：12345search: path: search.xml field: post format: html limit: 10000 &emsp;&emsp;修改主题配置文件：123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 20.创建分类页面 新建一个页面， 1hexo new page categories 编辑新建的页面，增加 1type: categories 屏蔽评论功能， 1comments: false 菜单中添加链接，编辑主题配置文件，解注释 1categories &emsp;&emsp;(tags页面类似)]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>Hexo Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假面饭店]]></title>
    <url>%2F2018%2F01%2F04%2F%E5%81%87%E9%9D%A2%E9%A5%AD%E5%BA%97%2F</url>
    <content type="text"><![CDATA[饭店人员一边想象着客人的本来面目，一边还必须要尊重他们的假面具，决不能试图摘下来。因为某种程度上，客人是为了享受面具舞会才来的饭店。 &emsp;&emsp;这本书和他之前的作品一样，阅读过程十分顺畅，多少有点欲罢不能。故事结构完整，情节设计精巧，但是推理节奏较为拖沓；最终决战到来之前的风雨欲来的紧迫感营造的很优秀，但是最终的杀人动机极为狗血。&emsp;&emsp;作者在主线情节的中间还穿插着一些支线情节，这些段落插曲一方面丰满了人物，另一方面也促进了情节的推动，每一个小故事或多或少的提供了一点线索。经纬度和环形密码还是比较有趣的。&emsp;&emsp;印象最深的还是男女主角对于工作的高度责任心。两个完全不相关的职业以及思考方式，在推理判断过程中的成长，从开始的互不理解到互相欣赏，在推理之余增加了温情。&emsp;&emsp;可能是因为之前看的东野的小说都太过经典和优秀（白夜行，解忧杂货铺等），所以对这本书阅读体验并不如期待。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>小说</tag>
      </tags>
  </entry>
</search>
